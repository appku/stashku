/*
 * ATTENTION: The "eval" devtool has been used (maybe by default in mode: "development").
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
var StashKu;
/******/ (() => { // webpackBootstrap
/******/ 	"use strict";
/******/ 	var __webpack_modules__ = ({

/***/ "./engines/base-engine.js":
/*!********************************!*\
  !*** ./engines/base-engine.js ***!
  \********************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (__WEBPACK_DEFAULT_EXPORT__)\n/* harmony export */ });\n/* harmony import */ var _requests_delete_request_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../requests/delete-request.js */ \"./requests/delete-request.js\");\n/* harmony import */ var _requests_get_request_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../requests/get-request.js */ \"./requests/get-request.js\");\n/* harmony import */ var _requests_options_request_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../requests/options-request.js */ \"./requests/options-request.js\");\n/* harmony import */ var _requests_patch_request_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../requests/patch-request.js */ \"./requests/patch-request.js\");\n/* harmony import */ var _requests_post_request_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../requests/post-request.js */ \"./requests/post-request.js\");\n/* harmony import */ var _requests_put_request_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ../requests/put-request.js */ \"./requests/put-request.js\");\n/* harmony import */ var _rest_error_js__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ../rest-error.js */ \"./rest-error.js\");\n/* harmony import */ var _filter_js__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ../filter.js */ \"./filter.js\");\n/* harmony import */ var _logger_js__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! ../logger.js */ \"./logger.js\");\n\n\n\n\n\n\n\n\n\n\n/**\n * @typedef\n */\n\n/**\n * This abstract base class defines the structure of a StashKu-compatible engine. All StashKu engines must extend this\n * class.    \n * \n * The implementing engine should implement it's own `schema`, `get`, `post`, `put`, `patch`, and `delete` functions\n * when supported. If the RESTful function is not supported it should not be overriden so that this base class can\n * throw a 501 \"Not supported\" error.\n * @abstract\n */\nclass BaseEngine {\n    /**\n     * Instantiates a new `BaseEngine`.\n     * @param {String} name - The name of this storage engine. \n     */\n    constructor(name) {\n        if (new.target === BaseEngine) {\n            throw new Error('BaseEngine is an abstract class and should not be initiated alone.');\n        } else if (!name) {\n            throw new Error('The \"name\" argument is required.');\n        } else if (typeof name !== 'string') {\n            throw new Error('The \"name\" argument must be a string.');\n        }\n\n        /**\n         * The name of this StashKu engine. This name is used in debugging and log output.\n         * @type {String}\n         */\n        this.name = name;\n\n        /**\n         * The configuration object for the storage engine.\n         * @type {*}\n         */\n        this.config = null;\n\n        /**\n         * @type {Logger}\n         */\n        this.log = null;\n\n    }\n\n    /**\n     * Standardized method to clean up resources within a storage engine. This is called from the StashKu instance when\n     * an engine is replaced or removed, or the instance is destroyed.\n     * @abstract\n     */\n    async destroy() { }\n\n    /**\n     * Sets the storage engine configuration property. This function is called automatically by StashKu when the engine\n     * is initialized or when the configuration source has been changed.\n     * @param {*} config - The configuration object for the storage engine.\n     * @param {Logger} [logger] - Optional `Logger` instance to set on the engine. This is usually assigned to the\n     * same instance as the StashKu parent.\n     * @abstract\n     */\n    configure(config, logger) {\n        this.config = config;\n        if (logger) {\n            this.log = logger;\n        } else if (logger === null) {\n            this.log = null;\n        }\n    }\n\n    /**\n     * Returns an array of strings naming the resources available in the storage medium accessible by the engine.\n     * @returns {Promise.<Array.<String>>}\n     * @abstract\n     */\n    async resources() {\n        throw new _rest_error_js__WEBPACK_IMPORTED_MODULE_6__[\"default\"](501, `The \"resources\" function is not supported on the StashKu \"${this.name}\" storage engine.`);\n    }\n\n    /**\n     * Run a GET `request` and returns objects from storage that match the GET `request` criteria.\n     * \n     * @throws A 501 REST error if not overriden and supported by the storage engine.\n     * @throws A 400 REST error if the request is missing or not a `GetRequest`.\n     * @throws A 400 REST error if the request missing required metadata.\n     * @throws A 400 REST error if the request metadata is missing a required \"from\" value.\n     * @param {GetRequest} request - The GET request to send to the storage engine.\n     * @returns {Promise.<Response>} Returns the data objects from storage matching request criteria.\n     * @abstract\n     */\n    async get(request) {\n        if (this.get === BaseEngine.prototype.get) {\n            throw new _rest_error_js__WEBPACK_IMPORTED_MODULE_6__[\"default\"](501, `The GET action is not supported on the StashKu \"${this.name}\" storage engine.`);\n        } else {\n            //perform request validations\n            if (!request || (request instanceof _requests_get_request_js__WEBPACK_IMPORTED_MODULE_1__[\"default\"]) === false) {\n                throw new _rest_error_js__WEBPACK_IMPORTED_MODULE_6__[\"default\"](400, 'The \"request\" argument is required and must be a GetRequest.');\n            } else if (!request.metadata) {\n                throw new _rest_error_js__WEBPACK_IMPORTED_MODULE_6__[\"default\"](400, 'The \"request\" argument is incomplete and missing required metadata.');\n            } else if (!request.metadata.from) {\n                throw new _rest_error_js__WEBPACK_IMPORTED_MODULE_6__[\"default\"](400, 'The request is missing a required \"from\" value.');\n            }\n        }\n    }\n\n    /**\n     * Run a POST `request` and creates (then returns) objects in storage.\n     * \n     * @throws A 501 REST error if not overriden and supported by the storage engine.\n     * @throws A 400 REST error if the request is missing or not a `PostRequest`.\n     * @throws A 400 REST error if the request missing required metadata.\n     * @throws A 400 REST error if the request metadata is missing a required \"to\" value.\n     * @param {PostRequest} request - The POST request to send to the storage engine.\n     * @returns {Promise.<Response>} Returns the data objects from storage that were created with the request criteria.\n     * @abstract\n     */\n    async post(request) {\n        if (this.post === BaseEngine.prototype.post) {\n            throw new _rest_error_js__WEBPACK_IMPORTED_MODULE_6__[\"default\"](501, `The POST action is not supported on the StashKu \"${this.name}\" storage engine.`);\n        } else {\n            //perform request validations\n            if (!request || (request instanceof _requests_post_request_js__WEBPACK_IMPORTED_MODULE_4__[\"default\"]) === false) {\n                throw new _rest_error_js__WEBPACK_IMPORTED_MODULE_6__[\"default\"](400, 'The \"request\" argument is required and must be a PostRequest.');\n            } else if (!request.metadata) {\n                throw new _rest_error_js__WEBPACK_IMPORTED_MODULE_6__[\"default\"](400, 'The \"request\" argument is incomplete and missing required metadata.');\n            } else if (!request.metadata.to) {\n                throw new _rest_error_js__WEBPACK_IMPORTED_MODULE_6__[\"default\"](400, 'The request is missing a required \"to\" value.');\n            }\n        }\n    }\n\n    /**\n     * Run a PUT `request` and updates (then returns) objects in storage.\n     * \n     * @throws A 501 REST error if not overriden and supported by the storage engine.\n     * @throws A 400 REST error if the request is missing or not a `PutRequest`.\n     * @throws A 400 REST error if the request missing required metadata.\n     * @throws A 400 REST error if the request metadata is missing a required \"to\" value.\n     * @throws A 400 REST error if the request metadata is missing at least one \"pk\" value.\n     * @param {PutRequest} request - The PUT request to send to the storage engine.\n     * @returns {Promise.<Response>} Returns the data objects from storage that were updated with the request criteria. This \n     * *__may not__* exactly match the objects requested to be updated, as some may have been deleted from storage or\n     * some may not match the key criteria.\n     * @abstract\n     */\n    async put(request) {\n        if (this.put === BaseEngine.prototype.put) {\n            throw new _rest_error_js__WEBPACK_IMPORTED_MODULE_6__[\"default\"](501, `The PUT action is not supported on the StashKu \"${this.name}\" storage engine.`);\n        } else {\n            //perform request validations\n            if (!request || (request instanceof _requests_put_request_js__WEBPACK_IMPORTED_MODULE_5__[\"default\"]) === false) {\n                throw new _rest_error_js__WEBPACK_IMPORTED_MODULE_6__[\"default\"](400, 'The \"request\" argument is required and must be a PutRequest.');\n            } else if (!request.metadata) {\n                throw new _rest_error_js__WEBPACK_IMPORTED_MODULE_6__[\"default\"](400, 'The \"request\" argument is incomplete and missing required metadata.');\n            } else if (!request.metadata.to) {\n                throw new _rest_error_js__WEBPACK_IMPORTED_MODULE_6__[\"default\"](400, 'The request is missing a required \"to\" value.');\n            } else if (!request.metadata.pk || request.metadata.pk.length === 0) {\n                throw new _rest_error_js__WEBPACK_IMPORTED_MODULE_6__[\"default\"](400, 'The request is missing at least one \"primary key\" (PK) property name.');\n            }\n        }\n    }\n    /**\n     * Run a PATCH `request` and updates all objects in storage matching the PATCH `request` criteria. A count of the\n     * number of objects affected is returned.\n     * \n     * @throws A 501 REST error if not overriden and supported by the storage engine.\n     * @throws A 400 REST error if the request is missing or not a `PatchRequest`.\n     * @throws A 400 REST error if the request missing required metadata.\n     * @throws A 400 REST error if the request metadata is missing a required \"to\" value.\n     * @throws A 400 REST error if the request metadata is missing a \"template\" object.\n     * @throws A 400 REST error if the request metadata is missing \"where\" conditions to match objects in storage and\n     * is not enabled to affect all objects.\n     * @param {PatchRequest} request - The PATCH request to send to the storage engine.\n     * @returns {Promise.<Response>} Returns a response with the total number of the objects affected in storage. No\n     * data objects are typically returned with this request.\n     * @abstract\n     */\n    async patch(request) {\n        if (this.patch === BaseEngine.prototype.patch) {\n            throw new _rest_error_js__WEBPACK_IMPORTED_MODULE_6__[\"default\"](501, `The PATCH action is not supported on the StashKu \"${this.name}\" storage engine.`);\n        } else {\n            //perform request validations\n            if (!request || (request instanceof _requests_patch_request_js__WEBPACK_IMPORTED_MODULE_3__[\"default\"]) === false) {\n                throw new _rest_error_js__WEBPACK_IMPORTED_MODULE_6__[\"default\"](400, 'The \"request\" argument is required and must be a PatchRequest.');\n            } else if (!request.metadata) {\n                throw new _rest_error_js__WEBPACK_IMPORTED_MODULE_6__[\"default\"](400, 'The \"request\" argument is incomplete and missing required metadata.');\n            } else if (!request.metadata.to) {\n                throw new _rest_error_js__WEBPACK_IMPORTED_MODULE_6__[\"default\"](400, 'The request is missing a required \"to\" value.');\n            } else if (!request.metadata.template) {\n                throw new _rest_error_js__WEBPACK_IMPORTED_MODULE_6__[\"default\"](400, 'The request is missing at a defined \"template\" object.');\n            } else if (!request.metadata.all && (!request.metadata.where || _filter_js__WEBPACK_IMPORTED_MODULE_7__[\"default\"].isEmpty(request.metadata.where))) {\n                throw new _rest_error_js__WEBPACK_IMPORTED_MODULE_6__[\"default\"](400, 'The request is missing \"where\" conditions to match objects in storage. If the intention is to affect all objects, the \"all\" flag must be enabled.');\n            }\n        }\n    }\n\n    /**\n     * Run a DELETE `request` and deletes all objects in storage matching the DELETE `request` criteria.\n     * \n     * @throws A 501 REST error if not overriden and supported by the storage engine.\n     * @throws A 400 REST error if the request is missing or not a `DeleteRequest`.\n     * @throws A 400 REST error if the request missing required metadata.\n     * @throws A 400 REST error if the request metadata is missing a required \"from\" value.\n     * @throws A 400 REST error if the request metadata is missing \"where\" conditions to match objects in storage and\n     * is not enabled to affect all objects.\n     * @param {DeleteRequest} request - The DELETE request to send to the storage engine.\n     * @returns {Promise.<Response>} Returns the data objects from storage that were deleted with the request criteria.\n     * @abstract\n     */\n    async delete(request) {\n        if (this.delete === BaseEngine.prototype.delete) {\n            throw new _rest_error_js__WEBPACK_IMPORTED_MODULE_6__[\"default\"](501, `The DELETE action is not supported on the StashKu \"${this.name}\" storage engine.`);\n        } else {\n            //perform request validations\n            if (!request || (request instanceof _requests_delete_request_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"]) === false) {\n                throw new _rest_error_js__WEBPACK_IMPORTED_MODULE_6__[\"default\"](400, 'The \"request\" argument is required and must be a DeleteRequest.');\n            } else if (!request.metadata) {\n                throw new _rest_error_js__WEBPACK_IMPORTED_MODULE_6__[\"default\"](400, 'The \"request\" argument is incomplete and missing required metadata.');\n            } else if (!request.metadata.from) {\n                throw new _rest_error_js__WEBPACK_IMPORTED_MODULE_6__[\"default\"](400, 'The request is missing a required \"from\" value.');\n            } else if (!request.metadata.all && (!request.metadata.where || _filter_js__WEBPACK_IMPORTED_MODULE_7__[\"default\"].isEmpty(request.metadata.where))) {\n                throw new _rest_error_js__WEBPACK_IMPORTED_MODULE_6__[\"default\"](400, 'The request is missing \"where\" conditions to match objects in storage and is not enabled to affect all objects.');\n            }\n        }\n    }\n\n    /**\n     * Run an OPTIONS `request` which returns a dynamically constructed model type which defines how StashKu can \n     * interact with the target (`from`) resource. \n     * \n     * @throws A 501 REST error if not overriden and supported by the storage engine.\n     * @throws A 400 REST error if the request is missing or not a `OptionsRequest`.\n     * @throws A 400 REST error if the request missing required metadata.\n     * @throws A 400 REST error if the request metadata is missing a required \"from\" value.\n     * @throws A 400 REST error if the request metadata is missing \"where\" conditions to match objects in storage and\n     * is not enabled to affect all objects.\n     * @param {OptionsRequest} request - The OPTIONS request to send to the storage engine.\n     * @returns {Promise.<Response>} Returns a response with a single data object- the dynamically created model\n     * configuration.\n     * @abstract\n     */\n    async options(request) {\n        if (this.options === BaseEngine.prototype.options) {\n            throw new _rest_error_js__WEBPACK_IMPORTED_MODULE_6__[\"default\"](501, `The OPTIONS action is not supported on the StashKu \"${this.name}\" storage engine.`);\n        } else {\n            //perform request validations\n            if (!request || (request instanceof _requests_options_request_js__WEBPACK_IMPORTED_MODULE_2__[\"default\"]) === false) {\n                throw new _rest_error_js__WEBPACK_IMPORTED_MODULE_6__[\"default\"](400, 'The \"request\" argument is required and must be a OptionsRequest.');\n            } else if (!request.metadata) {\n                throw new _rest_error_js__WEBPACK_IMPORTED_MODULE_6__[\"default\"](400, 'The \"request\" argument is incomplete and missing required metadata.');\n            } else if (!request.metadata.from) {\n                throw new _rest_error_js__WEBPACK_IMPORTED_MODULE_6__[\"default\"](400, 'The request is missing a required \"from\" value.');\n            }\n        }\n    }\n\n}\n\n/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (BaseEngine);\n\n//# sourceURL=webpack://StashKu/./engines/base-engine.js?");

/***/ }),

/***/ "./engines/fetch-engine.js":
/*!*********************************!*\
  !*** ./engines/fetch-engine.js ***!
  \*********************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (__WEBPACK_DEFAULT_EXPORT__)\n/* harmony export */ });\n/* harmony import */ var _requests_delete_request_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../requests/delete-request.js */ \"./requests/delete-request.js\");\n/* harmony import */ var _requests_get_request_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../requests/get-request.js */ \"./requests/get-request.js\");\n/* harmony import */ var _requests_options_request_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../requests/options-request.js */ \"./requests/options-request.js\");\n/* harmony import */ var _requests_patch_request_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../requests/patch-request.js */ \"./requests/patch-request.js\");\n/* harmony import */ var _requests_post_request_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../requests/post-request.js */ \"./requests/post-request.js\");\n/* harmony import */ var _requests_put_request_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ../requests/put-request.js */ \"./requests/put-request.js\");\n/* harmony import */ var _response_js__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ../response.js */ \"./response.js\");\n/* harmony import */ var _rest_error_js__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ../rest-error.js */ \"./rest-error.js\");\n/* harmony import */ var _filter_js__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! ../filter.js */ \"./filter.js\");\n/* harmony import */ var _logger_js__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! ../logger.js */ \"./logger.js\");\n/* harmony import */ var _modeling_model_generator_js__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(/*! ../modeling/model-generator.js */ \"./modeling/model-generator.js\");\n/* harmony import */ var _base_engine_js__WEBPACK_IMPORTED_MODULE_11__ = __webpack_require__(/*! ./base-engine.js */ \"./engines/base-engine.js\");\n/* harmony import */ var _sort_js__WEBPACK_IMPORTED_MODULE_12__ = __webpack_require__(/*! ../sort.js */ \"./sort.js\");\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nconst IS_BROWSER = (typeof window !== 'undefined');\nlet globalFetch = null;\n/* istanbul ignore next */\nconst lazyLoadGlobalFetch = async () => {\n    if (!globalFetch) {\n        if (IS_BROWSER) {\n            globalFetch = window.fetch; // eslint-disable-line no-undef\n        } else if (fetch) { // eslint-disable-line no-undef\n            globalFetch = fetch; // eslint-disable-line no-undef\n        } else {\n            globalFetch = await import(/* webpackIgnore: true */'node-fetch').default;\n        }\n    }\n};\n\n/**\n * @typedef FetchEngineConfiguration\n * @property {String} [root] - The root URI of each fetch request. If specified, will be prefixed to each resource.\n * @property {String} [path=\"/api\"] - The path to the URI endpoint. This is prefixed before each resource, but after \n * the `root` (if specified).\n * @property {Boolean} [trailingSlash=false] - Sets whether a slash will be added at the end of the generated URI.\n * @property {RequestInit} [fetch] - Optional fetch defaults to apply before request-specific configuration is set.\n */\n\n/**\n * @typedef {FetchEngineConfiguration} FetchRequestHeader\n */\n\n/**\n * This StashKu engine is built-in and provides an engine to make requests to HTTP endpoints using `fetch`. Requests \n * correspond to their HTTP request method.\n */\nclass FetchEngine extends _base_engine_js__WEBPACK_IMPORTED_MODULE_11__[\"default\"] {\n    /**\n     * Creates a new `MemoryStorageEngine` instance.\n     */\n    constructor() {\n        super('fetch');\n\n        /**\n         * @type {Map.<String, Array>}\n         */\n        this.data = new Map();\n\n        /**\n         * @type {MemoryStorageEngineConfiguration}\n         */\n        this.config = {\n            root: null,\n            path: null,\n            trailingSlash: false\n        };\n    }\n\n    /**\n     * @inheritdoc\n     * @param {MemoryStorageEngineConfiguration} config - The configuration object for the storage engine.\n     */\n    configure(config) {\n        super.configure(config);\n        let defaults = {\n            root: null,\n            path: null,\n            trailingSlash: false\n        };\n        if (IS_BROWSER === false) {\n            if (typeof process.env.STASHKU_FETCH_ROOT === 'string') {\n                defaults.root = process.env.STASHKU_FETCH_ROOT;\n            }\n            if (typeof process.env.STASHKU_FETCH_PATH === 'string') {\n                defaults.path = process.env.STASHKU_FETCH_PATH;\n            }\n            if (typeof process.env.STASHKU_FETCH_TRAILING_SLASH === 'string') {\n                defaults.trailingSlash = !!process.env.STASHKU_FETCH_TRAILING_SLASH.match(/^[tTyY1]/);\n            }\n        }\n        defaults = Object.assign(defaults, config);\n        this.config = defaults;\n    }\n\n    /**\n     * Builds the full target URI for the fetch request based on engine settings.\n     * The resource may be the literal resource target (string) or a model type.\n     * \n     * @throws Error if the resource value is null or undefined.\n     * @throws Error if a model type was specified but it is missing the resource value under the configured \n     * resource target.\n     * @param {String|Modeling.AnyModelType} resource - The resource name (or model type).\n     * @returns {String}\n     * @private\n     */\n    _uri(resource) {\n        if (resource === null || typeof resource === 'undefined') {\n            resource = '';\n        }\n        let uri = [this.config.root, this.config.path, resource].filter(v => typeof v === 'string').map(function (i) {\n            return i.replace(/(^\\/|\\/$)/g, '');\n        }).join('/');\n        if (this.config.trailingSlash && uri.endsWith('/') === false && uri.indexOf('?') < 0) {\n            uri += '/';\n        } else if (this.config.trailingSlash !== true && uri.endsWith('/')) {\n            uri = uri.substring(0, uri.length - 1);\n        }\n        if (uri.startsWith('/') === false && !this.config.root && !uri.match(/^.+\\/\\/+/)) {\n            uri = '/' + uri;\n        }\n        return uri;\n    }\n\n    /**\n     * Serializes the given object into a query paramater (URL) string.\n     * @param {*} obj - the object\n     * @param {*} prefix - the prefix\n     * @returns {String}\n     * @private\n     */\n    _paramSerialize(obj, prefix) {\n        let str = [], p;\n        for (p in obj) {\n            if (typeof obj[p] !== 'undefined') {\n                let k = prefix ? prefix + '[' + p + ']' : p,\n                    v = obj[p];\n                if (v !== null && typeof v === 'object') {\n                    if (v instanceof Date) {\n                        str.push(encodeURIComponent(k) + '=' + encodeURIComponent(v.toISOString()));\n                    } else {\n                        str.push(this._paramSerialize(v, k));\n                    }\n                } else {\n                    str.push(encodeURIComponent(k) + '=' + encodeURIComponent(v));\n                }\n            }\n        }\n        if (!str || str.length === 0) {\n            return null;\n        }\n        return str.join('&');\n    }\n\n    /**\n     * Makes a fetch call to a remote endpoint and returns the response.\n     * @param {String|Modeling.AnyModelType} resource - The resource name (or model type).\n     * @param {*} data - The data to be sent.\n     * @param {RequestInit} settings - The `fetch` settings to apply.\n     * @returns {Promise.<globalThis.Response>}\n     * @private\n     */\n    async _fetch(resource, data, settings) {\n        settings = Object.assign({\n            method: 'GET',\n            cache: 'no-cache'\n        }, this.config.fetch, settings);\n        let targetURI = this._uri(resource);\n        settings.method = settings.method.toUpperCase(); //always upper\n        if (data) {\n            if (settings.method === 'GET') {\n                let params = this._paramSerialize(data);\n                if (params) {\n                    targetURI += '?' + this._paramSerialize(data);\n                }\n            } else {\n                if (!settings.headers) {\n                    settings.headers = {};\n                }\n                settings.headers['Content-Type'] = 'application/json';\n                settings.body = JSON.stringify(data);\n            }\n        }\n        await lazyLoadGlobalFetch();\n        return globalFetch(targetURI, settings);\n    }\n\n    /**\n     * @inheritdoc\n     * @returns {Promise.<Array.<String>>}\n     */\n    async resources() {\n        let res = await this._fetch('resources');\n        let results = await res.json();\n        return results.data;\n    }\n\n    /**\n     * @override\n     * @param {GetRequest} request - The GET request to send to the storage engine.\n     * @returns {Promise.<Response>} Returns the data objects from storage matching request criteria.\n     */\n    async get(request) {\n        //validate\n        await super.get(request);\n        //make the request, wrap errors in RESTError\n        let payload = request.toJSON();\n        if (request.metadata.from === payload.from) { //when the request from and the uri resource are the same, there's no need to send the from parameter.\n            delete payload.from;\n        }\n        let res = await this._fetch(request.metadata.from, payload);\n        if (res.ok === false) {\n            throw new _rest_error_js__WEBPACK_IMPORTED_MODULE_7__[\"default\"](res.status, `Error from fetched resource (\"${this._uri(request.metadata.from)}\") in \"${request.method}\" request: ${res.statusText}`);\n        }\n        try {\n            let payload = await res.json();\n            return new _response_js__WEBPACK_IMPORTED_MODULE_6__[\"default\"](payload.data, payload.total, payload.affected, payload.returned, res.status);\n        } catch (err) {\n            throw new _rest_error_js__WEBPACK_IMPORTED_MODULE_7__[\"default\"](500, `Error attempting to parse fetch response as JSON resource (\"${this._uri(request.metadata.from)}\") in \"${request.method}\" request: ${err.message}`, err);\n        }\n    }\n\n    /**\n     * @override\n     * @param {PostRequest} request - The POST request to send to the storage engine.\n     * @returns {Promise.<Response>} Returns the data objects from storage that were created with the request criteria.\n     */\n    async post(request) {\n        //validate\n        await super.post(request);\n        //process\n        if (request.metadata.objects && request.metadata.objects.length) {\n            //make the request, wrap errors in RESTError\n            let res = await this._fetch(request.metadata.to, request, { method: request.method });\n            if (res.ok === false) {\n                throw new _rest_error_js__WEBPACK_IMPORTED_MODULE_7__[\"default\"](res.status, `Error from fetched resource (\"${this._uri(request.metadata.to)}\") in \"${request.method}\" request: ${res.statusText}`);\n            }\n            try {\n                let payload = await res.json();\n                return new _response_js__WEBPACK_IMPORTED_MODULE_6__[\"default\"](payload.data, payload.total, payload.affected, payload.returned, res.status);\n            } catch (err) {\n                throw new _rest_error_js__WEBPACK_IMPORTED_MODULE_7__[\"default\"](500, `Error attempting to parse fetch response as JSON resource (\"${this._uri(request.metadata.to)}\") in \"${request.method}\" request: ${err.message}`, err);\n            }\n        }\n        return _response_js__WEBPACK_IMPORTED_MODULE_6__[\"default\"].empty();\n    }\n\n    /**\n     * @override\n     * @param {PutRequest} request - The PUT request to send to the storage engine.\n     * @returns {Promise.<Response>} Returns the data objects from storage that were updated with the request criteria. This \n     * *__may not__* exactly match the objects requested to be updated, as some may have been deleted from storage or\n     * some may not match the key criteria.\n     */\n    async put(request) {\n        //validate\n        await super.put(request);\n        //process\n        if (request.metadata.objects && request.metadata.objects.length) {\n            //make the request, wrap errors in RESTError\n            let res = await this._fetch(request.metadata.to, request, { method: request.method });\n            if (res.ok === false) {\n                throw new _rest_error_js__WEBPACK_IMPORTED_MODULE_7__[\"default\"](res.status, `Error from fetched resource (\"${this._uri(request.metadata.to)}\") in \"${request.method}\" request: ${res.statusText}`);\n            }\n            try {\n                let payload = await res.json();\n                return new _response_js__WEBPACK_IMPORTED_MODULE_6__[\"default\"](payload.data, payload.total, payload.affected, payload.returned, res.status);\n            } catch (err) {\n                throw new _rest_error_js__WEBPACK_IMPORTED_MODULE_7__[\"default\"](500, `Error attempting to parse fetch response as JSON resource (\"${this._uri(request.metadata.to)}\") in \"${request.method}\" request: ${err.message}`, err);\n            }\n        }\n        return _response_js__WEBPACK_IMPORTED_MODULE_6__[\"default\"].empty();\n    }\n    /**\n     * @override\n     * @param {PatchRequest} request - The PATCH request to send to the storage engine.\n     * @returns {Promise.<Response>} Returns a response with the total number of the objects affected in storage. No\n     * data objects are typically returned with this request.\n     */\n    async patch(request) {\n        //validate\n        await super.patch(request);\n        //process\n        if (request.metadata.template) {\n            //make the request, wrap errors in RESTError\n            let res = await this._fetch(request.metadata.to, request, { method: request.method });\n            if (res.ok === false) {\n                throw new _rest_error_js__WEBPACK_IMPORTED_MODULE_7__[\"default\"](res.status, `Error from fetched resource (\"${this._uri(request.metadata.to)}\") in \"${request.method}\" request: ${res.statusText}`);\n            }\n            try {\n                let payload = await res.json();\n                return new _response_js__WEBPACK_IMPORTED_MODULE_6__[\"default\"](payload.data, payload.total, payload.affected, payload.returned, res.status);\n            } catch (err) {\n                throw new _rest_error_js__WEBPACK_IMPORTED_MODULE_7__[\"default\"](500, `Error attempting to parse fetch response as JSON resource (\"${this._uri(request.metadata.to)}\") in \"${request.method}\" request: ${err.message}`, err);\n            }\n        }\n        return _response_js__WEBPACK_IMPORTED_MODULE_6__[\"default\"].empty();\n    }\n\n    /**\n     * @override\n     * @param {DeleteRequest} request - The DELETE request to send to the storage engine.\n     * @returns {Promise.<Response>} Returns the data objects from storage that were deleted with the request criteria.\n     */\n    async delete(request) {\n        //validate\n        await super.delete(request);\n        //process\n        if (request.metadata.all || (request.metadata.where && _filter_js__WEBPACK_IMPORTED_MODULE_8__[\"default\"].isEmpty(request.metadata.where) === false)) {\n            //make the request, wrap errors in RESTError\n            let res = await this._fetch(request.metadata.from, request, { method: request.method });\n            if (res.ok === false) {\n                throw new _rest_error_js__WEBPACK_IMPORTED_MODULE_7__[\"default\"](res.status, `Error from fetched resource (\"${this._uri(request.metadata.from)}\") in \"${request.method}\" request: ${res.statusText}`);\n            }\n            try {\n                let payload = await res.json();\n                return new _response_js__WEBPACK_IMPORTED_MODULE_6__[\"default\"](payload.data, payload.total, payload.affected, payload.returned, res.status);\n            } catch (err) {\n                throw new _rest_error_js__WEBPACK_IMPORTED_MODULE_7__[\"default\"](500, `Error attempting to parse fetch response as JSON resource (\"${this._uri(request.metadata.from)}\") in \"${request.method}\" request: ${err.message}`, err);\n            }\n        }\n        return _response_js__WEBPACK_IMPORTED_MODULE_6__[\"default\"].empty();\n    }\n\n    /**\n     * @override\n     * @param {OptionsRequest} request - The OPTIONS request to send to the storage engine.\n     * @returns {Promise.<Response>} Returns a response with a single data object- the dynamically created model\n     * configuration.\n     */\n    async options(request) {\n        //validate\n        await super.options(request);\n        //make the request, wrap errors in RESTError\n        let res = await this._fetch(request.metadata.from, request, { method: request.method });\n        if (res.ok === false) {\n            throw new _rest_error_js__WEBPACK_IMPORTED_MODULE_7__[\"default\"](res.status, `Error from fetched resource (\"${this._uri(request.metadata.from)}\") in \"${request.method}\" request: ${res.statusText}`);\n        }\n        try {\n            let payload = await res.json();\n            return new _response_js__WEBPACK_IMPORTED_MODULE_6__[\"default\"](payload.data, payload.total, payload.affected, payload.returned, res.status);\n        } catch (err) {\n            throw new _rest_error_js__WEBPACK_IMPORTED_MODULE_7__[\"default\"](500, `Error attempting to parse fetch response as JSON resource (\"${this._uri(request.metadata.from)}\") in \"${request.method}\" request: ${err.message}`, err);\n        }\n    }\n\n}\n\n/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (FetchEngine);\n\n//# sourceURL=webpack://StashKu/./engines/fetch-engine.js?");

/***/ }),

/***/ "./engines/memory-engine.js":
/*!**********************************!*\
  !*** ./engines/memory-engine.js ***!
  \**********************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (__WEBPACK_DEFAULT_EXPORT__)\n/* harmony export */ });\n/* harmony import */ var _requests_delete_request_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../requests/delete-request.js */ \"./requests/delete-request.js\");\n/* harmony import */ var _requests_get_request_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../requests/get-request.js */ \"./requests/get-request.js\");\n/* harmony import */ var _requests_options_request_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../requests/options-request.js */ \"./requests/options-request.js\");\n/* harmony import */ var _requests_patch_request_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../requests/patch-request.js */ \"./requests/patch-request.js\");\n/* harmony import */ var _requests_post_request_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../requests/post-request.js */ \"./requests/post-request.js\");\n/* harmony import */ var _requests_put_request_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ../requests/put-request.js */ \"./requests/put-request.js\");\n/* harmony import */ var _response_js__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ../response.js */ \"./response.js\");\n/* harmony import */ var _rest_error_js__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ../rest-error.js */ \"./rest-error.js\");\n/* harmony import */ var _filter_js__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! ../filter.js */ \"./filter.js\");\n/* harmony import */ var _logger_js__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! ../logger.js */ \"./logger.js\");\n/* harmony import */ var _modeling_model_generator_js__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(/*! ../modeling/model-generator.js */ \"./modeling/model-generator.js\");\n/* harmony import */ var _base_engine_js__WEBPACK_IMPORTED_MODULE_11__ = __webpack_require__(/*! ./base-engine.js */ \"./engines/base-engine.js\");\n/* harmony import */ var _sort_js__WEBPACK_IMPORTED_MODULE_12__ = __webpack_require__(/*! ../sort.js */ \"./sort.js\");\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nconst IS_BROWSER = (typeof window !== 'undefined');\n\n/**\n * Compares two objects.\n * @param {*} source - Object to compare.\n * @param {*} target - Another object to compare.\n * @returns {Boolean}\n * @ignore\n */\nconst objectEqual = (source, target) => {\n    if (source === target) {\n        return true;\n    }\n    for (let key in source) {\n        if (source[key] !== target[key]) return false;\n    }\n    return true;\n};\n\n/**\n * @typedef MemoryEngineConfiguration\n * @property {Boolean} caseSensitive - Controls whether all resource names are stored in lower-case, and tracked\n * case-insensitively or not. By default this is unset in the configuration which will default to `false` internally\n * and allow it to be overridden by request headers. If set explicitly, the request header's `caseSensitive` flag \n * will be ignored.\n * @property {Number} limit - Limits the maximum number of objects that can be stored in the memory engine per resource\n * name. If this limit is reached, POST requests will throw an error.\n */\n\n/**\n * @typedef MemoryRequestHeader\n * @property {Boolean} caseSensitive - Instructs the memory storage engine to search for a resource by its lower-case\n * name (`false`) or regular-case (`true`). This will be ignored if the same flag (`caseSensitive`) is set on the \n * memory storage configuration.\n */\n\n/**\n * This StashKu engine is built-in and provides an in-memory data store with support for all StashKu RESTful actions\n * and operations. \n */\nclass MemoryEngine extends _base_engine_js__WEBPACK_IMPORTED_MODULE_11__[\"default\"] {\n    /**\n     * Creates a new `MemoryEngine` instance.\n     */\n    constructor() {\n        super('memory');\n\n        /**\n         * @type {Map.<String, Array>}\n         */\n        this.data = new Map();\n\n        /**\n         * @type {MemoryEngineConfiguration}\n         */\n        this.config = {\n            caseSensitive: null,\n            limit: 0\n        };\n    }\n\n    /**\n     * @inheritdoc\n     * @param {MemoryEngineConfiguration} config - The configuration object for the storage engine.\n     */\n    configure(config) {\n        super.configure(config);\n        let defaults = {\n            caseSensitive: null,\n            limit: 0\n        };\n        if (IS_BROWSER === false) {\n            let limit = parseInt(process.env.STASHKU_MEMORY_LIMIT);\n            if (limit) {\n                defaults.limit = limit;\n            }\n            if (typeof process.env.STASHKU_MEMORY_CASE_SENSITIVE === 'string') {\n                defaults.caseSensitive = !!process.env.STASHKU_MEMORY_CASE_SENSITIVE.match(/^[tTyY1]/);\n            }\n        }\n        this.config = Object.assign(defaults, config);\n    }\n\n    /**\n     * @inheritdoc\n     * @returns {Promise.<Array.<String>>}\n     */\n    async resources() {\n        return Array.from(this.data.keys());\n    }\n\n    /**\n     * Finds and adjusts the resource name of the given request with consideration to the case-sensitivity setting\n     * on the storage engine or per-request.\n     * @param {GetRequest | PatchRequest | PostRequest | PutRequest | OptionsRequest} request - The request to extract\n     * the resource (target) name from.\n     * @returns {String}\n     * @protected\n     */\n    resourceOf(request) {\n        let meta = request.metadata;\n        let target = meta.from || meta.to;\n        let caseSensitive = null;\n        if (meta.headers && meta.headers.has('caseSensitive')) {\n            caseSensitive = meta.headers.get('caseSensitive');\n        }\n        if (typeof this.config.caseSensitive !== 'undefined' && this.config.caseSensitive !== null) {\n            caseSensitive = this.config.caseSensitive;\n        }\n        return caseSensitive ? target : target?.toLowerCase();\n    }\n\n    /**\n     * @override\n     * @throws 404 Error when the requested resource is has not been stored in memory.\n     * @param {GetRequest} request - The GET request to send to the storage engine.\n     * @returns {Promise.<Response>} Returns the data objects from storage matching request criteria.\n     */\n    async get(request) {\n        //validate\n        await super.get(request);\n        let meta = request.metadata;\n        let from = this.resourceOf(request);\n        if (this.data.has(from) === false) {\n            throw new _rest_error_js__WEBPACK_IMPORTED_MODULE_7__[\"default\"](404, `The requested resource \"${meta.from}\" was not found.`);\n        }\n        //find objects\n        let matches = this.data.get(from);\n        if (meta.where && _filter_js__WEBPACK_IMPORTED_MODULE_8__[\"default\"].isEmpty(meta.where) === false) {\n            matches = matches.filter(v => meta.where.test(v));\n        }\n        //ensure we have a new array with new object references (shallow copy).\n        matches = matches.map(v => Object.assign({}, v));\n        //apply distinct\n        if (meta.distinct) {\n            matches = matches.reduce((pv, cu, i, arr) => {\n                let exists = pv.some((v) => objectEqual(cu, v));\n                if (!exists) {\n                    pv.push(cu);\n                }\n                return pv;\n            }, []);\n        }\n        //perform sorts (no need to run if just counting)\n        if (!meta.count && meta.sorts && meta.sorts.length) {\n            const fieldSorter = (sorts) => (a, b) => sorts.map(s => {\n                let dir = 1;\n                if (s.dir === _sort_js__WEBPACK_IMPORTED_MODULE_12__[\"default\"].DIR.DESC) {\n                    dir = -1;\n                }\n                return a[s.property] > b[s.property] ? dir : a[s.property] < b[s.property] ? -(dir) : 0;\n            }).reduce((p, n) => p ? p : n, 0);\n            matches.sort(fieldSorter(meta.sorts));\n        }\n        //apply paging\n        let total = matches.length; //save the total before reducing\n        if (meta.skip && meta.skip > 0) {\n            matches.splice(0, meta.skip);\n        }\n        if (meta.take && meta.take > 0) {\n            matches = matches.slice(0, meta.take);\n        }\n        //handle count-only requests\n        if (meta.count) {\n            let res = new _response_js__WEBPACK_IMPORTED_MODULE_6__[\"default\"](null, total, 0, matches.length);\n            return res;\n        } else {\n            //apply property limitations (if any)\n            if (meta.properties && meta.properties.length) {\n                for (let m of matches) {\n                    //delete any keys not in specified properties\n                    Object.keys(m)\n                        .filter(k => meta.properties.indexOf(k) < 0)\n                        .map(k => delete m[k]);\n                }\n            }\n            return new _response_js__WEBPACK_IMPORTED_MODULE_6__[\"default\"](matches, total, 0, matches.length);\n        }\n    }\n\n    /**\n     * @override\n     * @description\n     * This will create the resource in memory if it does not already exist.\n     * @param {PostRequest} request - The POST request to send to the storage engine.\n     * @returns {Promise.<Response>} Returns the data objects from storage that were created with the request criteria.\n     */\n    async post(request) {\n        //validate\n        await super.post(request);\n        //process\n        let meta = request.metadata;\n        if (meta.objects && meta.objects.length) {\n            let to = this.resourceOf(request);\n            if (this.data.has(to) === false) {\n                this.data.set(to, []);\n            }\n            let resource = this.data.get(to);\n            let storageClones = meta.objects.map(v => Object.assign({}, v));\n            let responseClones = meta.objects.map(v => Object.assign({}, v));\n            if (this.config && this.config.limit && resource.length + storageClones.length > this.config.limit) {\n                throw new _rest_error_js__WEBPACK_IMPORTED_MODULE_7__[\"default\"](400, `Cannot add additional objects to storage. The limit of ${this.config.limit} objects would be exceeded.`);\n            }\n            resource.push(...storageClones);\n            if (meta.count) {\n                return new _response_js__WEBPACK_IMPORTED_MODULE_6__[\"default\"](null, responseClones.length, responseClones.length, responseClones.length);\n            } else {\n                return new _response_js__WEBPACK_IMPORTED_MODULE_6__[\"default\"](responseClones, responseClones.length, responseClones.length, responseClones.length);\n            }\n        }\n        return _response_js__WEBPACK_IMPORTED_MODULE_6__[\"default\"].empty();\n    }\n\n    /**\n     * @override\n     * @throws 404 Error when the requested resource is has not been stored in memory.\n     * @param {PutRequest} request - The PUT request to send to the storage engine.\n     * @returns {Promise.<Response>} Returns the data objects from storage that were updated with the request criteria. This \n     * *__could potentially not__* exactly match the objects requested to be updated, as some may have been deleted from storage or\n     * some may not match the primary key criteria.\n     */\n    async put(request) {\n        //validate\n        await super.put(request);\n        let meta = request.metadata;\n        let to = this.resourceOf(request);\n        if (this.data.has(to) === false) {\n            throw new _rest_error_js__WEBPACK_IMPORTED_MODULE_7__[\"default\"](404, `The requested resource \"${meta.to}\" was not found.`);\n        }\n        //process\n        if (meta.objects && meta.objects.length) {\n            let resource = this.data.get(to);\n            let res = new _response_js__WEBPACK_IMPORTED_MODULE_6__[\"default\"]();\n            for (let o of meta.objects) {\n                //find existing\n                let record = resource.filter(r => meta.pk.every(k => r[k] === o[k]));\n                if (record.length > 1) {\n                    let values = meta.pk.map(k => o[k]);\n                    throw new _rest_error_js__WEBPACK_IMPORTED_MODULE_7__[\"default\"](409, `Multiple objects exist matching the specified primary keys (\"${meta.pk.join('\", \"')}\" with values \"=${values.join('; =')}\"). Only one to one matches are allowed.`);\n                } else if (record.length === 1) {\n                    //found a match, update and send in response...\n                    Object.assign(record[0], o); //update record with properties/values from o.\n                    res.data.push(Object.assign({}, record[0])); //store shallow clone in response so original is not affected.\n                }\n            }\n            //send response\n            res.total = res.data.length;\n            res.affected = res.data.length;\n            res.returned = res.data.length;\n            if (meta.count) {\n                res.data.length = 0;\n            }\n            return res;\n        }\n        return _response_js__WEBPACK_IMPORTED_MODULE_6__[\"default\"].empty();\n    }\n    /**\n     * @override\n     * @throws 404 Error when the requested resource is has not been stored in memory.\n     * @param {PatchRequest} request - The PATCH request to send to the storage engine.\n     * @returns {Promise.<Response>} Returns a response with the total number of the objects affected in storage. No\n     * data objects are typically returned with this request.\n     */\n    async patch(request) {\n        //validate\n        await super.patch(request);\n        let meta = request.metadata;\n        let to = this.resourceOf(request);\n        if (this.data.has(to) === false) {\n            throw new _rest_error_js__WEBPACK_IMPORTED_MODULE_7__[\"default\"](404, `The requested resource \"${meta.to}\" was not found.`);\n        }\n        //find objects\n        let matches = this.data.get(to);\n        if (meta.where && _filter_js__WEBPACK_IMPORTED_MODULE_8__[\"default\"].isEmpty(meta.where) === false) {\n            matches = matches.filter(v => meta.where.test(v));\n        }\n        //perform update\n        matches.map(m => Object.assign(m, meta.template));\n        if (meta.count) {\n            return new _response_js__WEBPACK_IMPORTED_MODULE_6__[\"default\"](null, matches.length, matches.length, matches.length);\n        } else {\n            let responseClones = matches.map(v => Object.assign({}, v));\n            return new _response_js__WEBPACK_IMPORTED_MODULE_6__[\"default\"](responseClones, responseClones.length, responseClones.length, responseClones.length);\n        }\n    }\n\n    /**\n     * @override\n     * @description\n     * If the last item from memory is deleted, the resource is also deleted from memory (resulting in a 404 for the\n     * resource until a new record is added under that resource name).\n     * @throws 404 Error when the requested resource is has not been stored in memory.\n     * @param {DeleteRequest} request - The DELETE request to send to the storage engine.\n     * @returns {Promise.<Response>} Returns the data objects from storage that were deleted with the request criteria.\n     */\n    async delete(request) {\n        await super.delete(request); //validate\n        let meta = request.metadata;\n        let from = this.resourceOf(request);\n        if (this.data.has(from) === false) {\n            throw new _rest_error_js__WEBPACK_IMPORTED_MODULE_7__[\"default\"](404, `The requested resource \"${meta.from}\" was not found.`);\n        }\n        //find objects\n        let matches = this.data.get(from);\n        if (meta.where && _filter_js__WEBPACK_IMPORTED_MODULE_8__[\"default\"].isEmpty(meta.where) === false) {\n            matches = matches.filter(v => meta.where.test(v));\n        }\n        //perform delete\n        let storage = this.data.get(from);\n        for (let m of matches) {\n            let index = storage.findIndex(v => v === m);\n            if (index >= 0) {\n                storage.splice(index, 1);\n            }\n        }\n        if (meta.count) {\n            return new _response_js__WEBPACK_IMPORTED_MODULE_6__[\"default\"](null, matches.length, matches.length, matches.length);\n        } else {\n            return new _response_js__WEBPACK_IMPORTED_MODULE_6__[\"default\"](matches, matches.length, matches.length, matches.length);\n        }\n    }\n\n    /**\n     * @override\n     * @throws 404 Error when the requested resource is has not been stored in memory.\n     * @param {OptionsRequest} request - The OPTIONS request to send to the storage engine.\n     * @returns {Promise.<Response>} Returns a response with a single data object- the dynamically created model\n     * configuration.\n     */\n    async options(request) {\n        //validate\n        await super.options(request);\n        let meta = request.metadata;\n        let resources = [];\n        let modelTypes = [];\n        if (request.metadata.from === '*') {\n            resources.push(...this.data.keys());\n        } else {\n            resources.push(this.resourceOf(request));\n        }\n        for (let from of resources) {\n            if (this.data.has(from) === false) {\n                throw new _rest_error_js__WEBPACK_IMPORTED_MODULE_7__[\"default\"](404, `The requested resource \"${meta.from}\" was not found.`);\n            }\n            let properties = new Map();\n            let matches = this.data.get(from);\n            //find properties - evaluate all records in resource\n            for (let m of matches) {\n                let keys = Object.keys(m);\n                for (let k of keys) {\n                    //build definition\n                    let def = properties.get(k);\n                    if (properties.has(k) === false) {\n                        def = {\n                            target: k,\n                            type: m[k]?.constructor?.name || null,\n                        };\n                        properties.set(k, def);\n                    }\n                    //keep trying to discover the type if a value has not been previously found.\n                    if (typeof def.type === 'undefined' || def.type === null) {\n                        def.type = m[k]?.constructor?.name || null;\n                    }\n                }\n            }\n            //generate model type and return\n            let mt = _modeling_model_generator_js__WEBPACK_IMPORTED_MODULE_10__[\"default\"].generateModelType(from, properties, { resource: from });\n            modelTypes.push(mt);\n        }\n        return new _response_js__WEBPACK_IMPORTED_MODULE_6__[\"default\"](modelTypes, modelTypes.length, 0, modelTypes.length);\n    }\n\n}\n\n/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (MemoryEngine);\n\n//# sourceURL=webpack://StashKu/./engines/memory-engine.js?");

/***/ }),

/***/ "./filter.js":
/*!*******************!*\
  !*** ./filter.js ***!
  \*******************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (__WEBPACK_DEFAULT_EXPORT__)\n/* harmony export */ });\n///<reference path=\"./modeling/modeling.d.js\" />\n\n/**\n * @typedef FilterCondition\n * @property {String} property - The property name from the schema affected by the filter.\n * @property {String} op - The filter operator.\n * @property {*} [value] - The value used by the operator on the property value.\n */\n\n/**\n * @typedef FilterLogicalGroup\n * @property {String} logic - The logical operator to apply to the filters.\n * @property {Array.<FilterCondition|FilterLogicalGroup>} filters - The filter items and groups under the logical operator.\n */\n\n/**\n * A regular expression to check for a reasonable ISO8601 format date.\n * YYYY-MM-DDThh:mm\n * YYYY-MM-DDThh:mmTZD\n * YYYY-MM-DDThh:mm:ss\n * YYYY-MM-DDThh:mm:ssTZD\n * YYYY-MM-DDThh:mm:ss.s\n * YYYY-MM-DDThh:mm:ss.sTZD\n * @see: https://www.w3.org/TR/NOTE-datetime\n * @type {RegExp}\n */\nconst ISO8601Date = /^\\d{4}-\\d\\d-\\d\\dT\\d\\d:\\d\\d(:\\d\\d(\\.\\d+)?)?(([+-]\\d\\d:\\d\\d)|Z)?$/i;\nconst NakedValueTokenTerminator = /\\s|\\)|\\(|\\[|\\]/;\n\n/**\n * Represents a tree of conditions that can be used to filter objects and data based on \"properties\", \"operations\", and\n * \"values\" in logical and/or groupings.\n */\nclass Filter {\n    /**\n     * Creates a new `Filter` instance.\n     * @param {Filter|FilterLogicalGroup} [tree] - Create the filter with an existing filter tree object.\n     */\n    constructor(tree) {\n\n        /**\n         * @type {FilterLogicalGroup}\n         */\n        this.tree = null;\n\n        /**\n         * @type {FilterLogicalGroup}\n         * @private\n         */\n        this._current = null;\n\n        /**\n         * When enabled (default) the Filter will support dot-notation property names, allowing nested object value\n         * evaluation. If disabled, dot-notation property names will be treated as the explicit property name.\n         * @type {Boolean}\n         */\n        this.dot = true;\n\n        /**\n         * @type {Filter.LOGIC}\n         * @ignore\n         */\n        this.LOGIC = Filter.LOGIC;\n\n        /**\n         * @type {Filter.OP}\n         * @ignore\n         */\n        this.OP = Filter.OP;\n\n        //init and validate tree\n        if (tree) {\n            let cleanup = (fg) => {\n                if (fg.logic && fg.filters && Array.isArray(fg.filters)) {\n                    for (let f of fg.filters) {\n                        cleanup(f);\n                    }\n                } else if (fg.field || fg.operator) {\n                    if (fg.field) {\n                        //convert property \"field\" to \"property\"\n                        fg.property = fg.field;\n                        delete fg.field;\n                    }\n                    if (fg.operator) {\n                        //convert property \"operator\" to \"op\"\n                        fg.op = fg.operator;\n                        delete fg.operator;\n                    }\n                } \n                if (typeof fg.property === 'undefined' && typeof fg.op === 'undefined' && typeof fg.logic === 'undefined' && typeof fg.filters === 'undefined') {\n                    throw new Error('Invalid filter tree. Found unexpected object that does not appear to be a condition or filter-group (missing expected properties).');\n                }\n                return fg;\n            };\n            if (tree instanceof Filter) {\n                this.tree = tree.tree;\n            } else if (tree.logic) { //tree-like object\n                this.tree = cleanup(tree);\n            } else {\n                throw new Error('Invalid filter tree. Found unexpected object that does not appear to be a condition or filter-group (missing expected properties).');\n            }\n        }\n    }\n\n    /**\n     * Create a new `Filter` instance and opening with a logical \"and\" operator.\n     * @param {String|Filter|FilterLogicalGroup|Modeling.PropertyDefinition} property - The property affected by the filter.\n     * @param {String} [op] - The filter operator.\n     * @param {*} [value] - The value used by the operator on the property value.\n     * @returns {Filter}\n     */\n    static and(property, op, value) {\n        return new Filter().and(property, op, value);\n    }\n\n    /**\n     * Create a new `Filter` instance and opening with a logical \"or\" operator.\n     * @param {String|Filter|FilterLogicalGroup|Modeling.PropertyDefinition} property - The property affected by the filter.\n     * @param {String} [op] - The filter operator.\n     * @param {*} [value] - The value used by the operator on the property value.\n     * @returns {Filter}\n     */\n    static or(property, op, value) {\n        return new Filter().or(property, op, value);\n    }\n\n    /**\n     * Checks if the specified filter is empty (contains no logical conditions) and returns a `true` if empty, `false`\n     * if not.\n     * @param {Filter|FilterLogicalGroup} filter - The filter to check.\n     * @returns {Boolean}\n     */\n    static isEmpty(filter) {\n        if (filter) {\n            if (filter instanceof Filter) {\n                return Filter.isEmpty(filter.tree);\n            } else {\n                for (let f of filter.filters) {\n                    if (f.property) {\n                        return false;\n                    } else if (f.logic) {\n                        if (Filter.isEmpty(f) === false) {\n                            return false;\n                        }\n                    }\n                }\n            }\n        }\n        return true;\n    }\n\n    /**\n     * Adds a new condition using a logical \"or\" operator.\n     * @param {String|Filter|FilterLogicalGroup|Modeling.PropertyDefinition} property - The property affected by the filter.\n     * @param {String} [op] - The filter operator.\n     * @param {*} [value] - The value used by the operator on the property value.\n     * @returns {Filter}\n     */\n    and(property, op, value) {\n        return this.add(Filter.LOGIC.AND, property, op, value);\n    }\n\n    /**\n     * Adds a new condition using a logical \"or\" operator.\n     * @param {String|Filter|FilterLogicalGroup|Modeling.PropertyDefinition} property - The property affected by the filter.\n     * @param {String} [op] - The filter operator.\n     * @param {*} [value] - The value used by the operator on the property value.\n     * @returns {Filter}\n     */\n    or(property, op, value) {\n        return this.add(Filter.LOGIC.OR, property, op, value);\n    }\n\n    /**\n     * Adds a new condition or filter group to the tree using the given logical operator.\n     * @param {String} logic - The logical operator.\n     * @param {String|Filter|FilterLogicalGroup|Modeling.PropertyDefinition} property - The property affected by the filter.\n     * @param {String} [op] - The filter operator.\n     * @param {*} [value] - The value used by the operator on the property value.\n     * @returns {Filter} \n     */\n    add(logic, property, op, value) {\n        //convert logic aliases\n        if (logic === '&&') {\n            logic = Filter.LOGIC.AND;\n        } else if (logic === '||') {\n            logic = Filter.LOGIC.OR;\n        }\n        //validate\n        if (!logic) {\n            throw new Error('The \"logic\" parameter argument is required.');\n        } else if (Filter.LOGIC_KEYS.indexOf(logic) <= -1) {\n            throw new Error(`The \"logic\" parameter argument \"${logic}\" is invalid or unsupported.`);\n        } else if (!property) {\n            throw new Error('The \"property\" parameter argument is required.');\n        }\n        //ensure there is a tree object.\n        if (!this.tree) {\n            this.tree = this._filterLogicalGroup(logic);\n            this._current = this.tree;\n        }\n        //add another filter logical group\n        if (property instanceof Filter) {\n            if (property.tree) {\n                property = property.tree;\n            } else {\n                return this; //empty filter\n            }\n        }\n        if (property.logic && property.filters) { // a filter condition\n            this._current.filters.push(property);\n            return this;\n        } else if (property.target) { //a property definition\n            property = property.target;\n        }\n        //add a condition\n        if (this._current.logic === logic) {\n            this._current.filters.push(this._filterCondition(property, op, value));\n        } else {\n            //wrap the current logical group with the new operator, then add the new condition\n            let lg = this._filterLogicalGroup(this._current.logic);\n            lg.filters = this._current.filters;\n            this._current.logic = logic;\n            this._current.filters = [lg, this._filterCondition(property, op, value)];\n        }\n        return this;\n    }\n\n    /**\n     * Creates a new logical group object.\n     * @param {String} logic - The logical operator.\n     * @returns {FilterLogicalGroup}\n     * @private\n     */\n    _filterLogicalGroup(logic) {\n        if (!logic) {\n            throw new Error('The \"logic\" parameter argument is required.');\n        } else if (Filter.LOGIC_KEYS.indexOf(logic) <= -1) {\n            throw new Error(`The \"logic\" parameter argument \"${logic}\" is invalid or unsupported.`);\n        }\n        return {\n            logic: logic,\n            filters: []\n        };\n    }\n\n    /**\n     * Creates a new condition object.\n     * @param {String} property - The property affected by the filter.\n     * @param {String} [op] - The filter operator.\n     * @param {*} [value] - The value used by the operator on the property value.\n     * @returns {FilterCondition}\n     * @private\n     */\n    _filterCondition(property, op, value) {\n        if (!property) {\n            throw new Error('The \"property\" parameter argument is required.');\n        } else if (!op) {\n            throw new Error('The \"op\" parameter argument is required.');\n        } else if (Filter.OP_KEYS.indexOf(op) <= -1) {\n            throw new Error(`The \"op\" parameter argument \"${op}\" is invalid or unsupported.`);\n        }\n        return {\n            property: property,\n            op: op,\n            value: value\n        };\n    }\n\n    /**\n     * Creates a clone of this filter.\n     * \n     * Note: Instance values on filter items are not deep-cloned.\n     * @returns {Filter}\n     */\n    clone() {\n        let f = new Filter();\n        if (this.tree) {\n            f.tree = this._cloneFilterGroup(this.tree);\n        }\n        return f;\n    }\n\n    /**\n     * Makes a copy of the filter group and returns the clone.\n     * @param {FilterLogicalGroup} orig - The group to clone.\n     * @returns {FilterLogicalGroup}\n     * @private\n     */\n    _cloneFilterGroup(orig) {\n        let g = this._filterLogicalGroup(orig.logic);\n        for (let f of orig.filters) {\n            if (f.property) {\n                g.filters.push(Object.assign({}, f));\n            } else if (f.logic) {\n                g.filters.push(this._cloneFilterGroup(f));\n            }\n        }\n        return g;\n    }\n\n    /**\n     * Tests the filter criteria against the specified model(s). If any model fails a filter, or no models are\n     * specified, a `false` value is returned. If all models pass the filters, a `true` value is returned.\n     * @param {...Model} models - The models to test the filter against.\n     * @returns {Boolean}\n     */\n    test(...models) {\n        if (models && models.length) {\n            if (this.tree && Filter.isEmpty(this) === false && Array.isArray(this.tree.filters) && this.tree.filters.length) {\n                for (let x = models.length - 1; x >= 0; x--) {\n                    if (this._evaluateCriteria(this.tree, models[x]) === false) {\n                        return false;\n                    }\n                }\n            }\n            return true;\n        }\n        return false;\n    }\n\n    /**\n     * Checks if the given model matches the given filter group criteria.\n     * @param {FilterLogicalGroup|FilterCondition} conditionOrGroup - The filter criteria to check.\n     * @param {Model} model - The model to evaluate. \n     * @returns {Boolean}\n     * @private\n     */\n    _evaluateCriteria(conditionOrGroup, model) {\n        if (conditionOrGroup.logic && conditionOrGroup.filters && Array.isArray(conditionOrGroup.filters)) {\n            let group = conditionOrGroup;\n            let result = (group.logic === Filter.LOGIC.AND);\n            if (group.logic === Filter.LOGIC.OR) {\n                for (let f of group.filters) {\n                    result |= this._evaluateCriteria(f, model);\n                }\n            } else if (group.logic === Filter.LOGIC.AND) {\n                for (let f of group.filters) {\n                    result &= this._evaluateCriteria(f, model);\n                }\n            }\n            return !!result;\n        } else if (conditionOrGroup.property && conditionOrGroup.op) {\n            let condition = conditionOrGroup;\n            let modelValue = null;\n            if (this.dot && condition.property.indexOf('.') >= 0) {\n                modelValue = condition.property.split('.').reduce((o, i) => o[i], model);\n            } else {\n                modelValue = model[condition.property];\n            }\n            switch (condition.op) {\n                case Filter.OP.NOTEQUALS:\n                    return modelValue != condition.value;\n                case Filter.OP.ISNULL:\n                    return modelValue === null;\n                case Filter.OP.ISNOTNULL:\n                    return modelValue !== null;\n                case Filter.OP.LESSTHAN:\n                    return modelValue < condition.value;\n                case Filter.OP.LESSTHANOREQUAL:\n                    return modelValue <= condition.value;\n                case Filter.OP.GREATERTHAN:\n                    return modelValue > condition.value;\n                case Filter.OP.GREATERTHANOREQUAL:\n                    return modelValue >= condition.value;\n                case Filter.OP.STARTSWITH: {\n                    let a = modelValue ? modelValue.toString() : '';\n                    let b = condition.value ? condition.value.toString() : '';\n                    return a.startsWith(b);\n                }\n                case Filter.OP.ENDSWITH: {\n                    let a = modelValue ? modelValue.toString() : '';\n                    let b = condition.value ? condition.value.toString() : '';\n                    return a.endsWith(b);\n                }\n                case Filter.OP.CONTAINS: {\n                    let a = modelValue ? modelValue.toString() : '';\n                    let b = condition.value ? condition.value.toString() : '';\n                    return (a.indexOf(b) > -1);\n                }\n                case Filter.OP.DOESNOTCONTAIN: {\n                    let a = modelValue ? modelValue.toString() : '';\n                    let b = condition.value ? condition.value.toString() : '';\n                    return (a.indexOf(b) < 0);\n                }\n                case Filter.OP.ISEMPTY:\n                    return typeof modelValue === 'undefined'\n                        || modelValue === null\n                        || modelValue === '';\n                case Filter.OP.ISNOTEMPTY:\n                    return typeof modelValue !== 'undefined'\n                        && modelValue != null\n                        && modelValue !== '';\n                case Filter.OP.IN:\n                    if (Array.isArray(condition.value) || typeof condition.value === 'string') {\n                        return condition.value.indexOf(modelValue) > -1;\n                    } else {\n                        return false;\n                    }\n                case Filter.OP.NOTIN:\n                    if (Array.isArray(condition.value) || typeof condition.value === 'string') {\n                        return condition.value.indexOf(modelValue) < 0;\n                    } else {\n                        return true;\n                    }\n                default: //eq\n                    return modelValue === condition.value;\n            }\n        }\n    }\n\n    /**\n     * Converts the filter to a readable string.\n     * @param {FilterLogicalGroup|FilterCondition} [fg] - Optional filter condition or filter group to convert to a string.\n     * @returns {String}\n     */\n    toString(fg) {\n        let s = null;\n        if (fg) {\n            if (fg.logic) {\n                if (fg.filters) {\n                    if (fg !== this.tree) {\n                        s = '(';\n                    } else {\n                        s = '';\n                    }\n                    for (let x = 0; x < fg.filters.length; x++) {\n                        s += this.toString(fg.filters[x]);\n                        if (fg.filters.length > 1 && x < fg.filters.length - 1) {\n                            s += ` ${fg.logic.toUpperCase()} `;\n                        }\n                    }\n                    if (fg !== this.tree) {\n                        s += ')';\n                    }\n                }\n            } else if (fg.property && fg.op) {\n                if (fg.op === Filter.OP.ISNULL\n                    || fg.op === Filter.OP.ISNOTNULL\n                    || fg.op === Filter.OP.ISEMPTY\n                    || fg.op === Filter.OP.ISNOTEMPTY) {\n                    s = `{${fg.property}} ${fg.op.toUpperCase()}`;\n                } else {\n                    let strValue = null;\n                    if (Array.isArray(fg.value)) {\n                        strValue = '[' + fg.value.map(v => {\n                            if (typeof v === 'string') {\n                                return `\"${v}\"`;\n                            } else if (v === null) {\n                                return 'null';\n                            } else if (typeof v === 'undefined') {\n                                return 'undefined';\n                            } else if (v instanceof Date) {\n                                return `\"${v.toISOString()}\"`;\n                            } else {\n                                return v.toString();\n                            }\n                        }).join(',') + ']';\n                    } else if (typeof fg.value === 'string') {\n                        strValue = `\"${fg.value}\"`;\n                    } else if (fg.value === null) {\n                        strValue = 'null';\n                    } else if (typeof fg.value === 'undefined') {\n                        strValue = 'undefined';\n                    } else if (fg.value instanceof Date) {\n                        strValue = `\"${fg.value.toISOString()}\"`;\n                    } else {\n                        strValue = fg.value.toString();\n                    }\n                    s = `{${fg.property}} ${fg.op.toUpperCase()} ${strValue}`;\n                }\n            }\n        } else {\n            s = this.toString(this.tree);\n        }\n        return s;\n    }\n\n    /**\n     * Returns the tree object to be utilized for stringifying into JSON.\n     * @returns {FilterLogicalGroup}\n     */\n    toJSON() {\n        return this.tree;\n    }\n\n    /**\n     * Creates a new `Filter` instance using the object containing a filter tree.\n     * @param {FilterLogicalGroup} obj - The filter tree object.\n     * @returns {Filter}\n     */\n    static fromObject(obj) {\n        return new Filter(obj);\n    }\n\n    /**\n     * Recursive function that parses each \"group\" it finds into a new `Filter` instance.\n     * @throws SyntaxError if the string is unparsable.\n     * @param {String|Array.<ParserToken>} input - The input string to parse into a new `Filter` instance.\n     * @returns {Filter} Returns a `Filter` instance when an input is given. If the input is `null` then `null` \n     * is returned.\n     */\n    static parse(input) {\n        if (input) {\n            let tokens;\n            if (typeof input === 'string') {\n                tokens = Filter._tokenize(input);\n            } else if (Array.isArray(input)) {\n                tokens = input;\n            } else {\n                throw new SyntaxError('Invalid \"input\" argument. Input must be a string or array of tokens.');\n            }\n            let f = new Filter();\n            //look-ahead for group-logic\n            let groupDepth = 0;\n            let groupLogic = Filter.LOGIC.AND;\n            for (let gei = 0; gei < tokens.length; gei++) {\n                if (tokens[gei].type === 'group-start') {\n                    groupDepth++;\n                } else if (groupDepth > 0 && tokens[gei].type === 'group-end') {\n                    groupDepth--;\n                } else if (groupDepth === 0 && tokens[gei].type === 'group-logic') {\n                    groupLogic = tokens[gei].value;\n                }\n            }\n            for (let ti = 0; ti < tokens.length; ti++) {\n                let t = tokens[ti];\n                if (t.type === 'group-start') {\n                    //find ending token index for the group, and determine logic\n                    let endingTokenIndex = -1;\n                    let groupDepth = 0;\n                    for (let gei = ti + 1; gei < tokens.length; gei++) {\n                        if (tokens[gei].type === 'group-start') {\n                            groupDepth++;\n                        } else if (groupDepth > 0 && tokens[gei].type === 'group-end') {\n                            groupDepth--;\n                        } else if (groupDepth === 0 && tokens[gei].type === 'group-end') {\n                            endingTokenIndex = gei;\n                        }\n                    }\n                    //create new group\n                    let tokensInGroup = tokens.slice(ti + 1, endingTokenIndex);\n                    if (tokensInGroup && tokensInGroup.length) {\n                        let fg = this.parse(tokensInGroup);\n                        f.add(groupLogic, fg);\n                    }\n                    //move to after the group to process next\n                    ti = endingTokenIndex;\n                } else if (t.type === 'condition-property') {\n                    //look-ahead and get the op and optional value.\n                    let tOp = tokens[ti + 1];\n                    let tValue;\n                    if (ti + 2 < tokens.length && tokens[ti + 2].type === 'condition-value') {\n                        tValue = tokens[ti + 2];\n                    }\n                    f.add(groupLogic, t.value, tOp.value, Filter._parseValueString(tValue?.value));\n                }\n            }\n            return f;\n        }\n        return null;\n    }\n\n    /**\n     * @typedef ParserToken\n     * @property {String} type\n     * @property {Number} startIndex\n     * @property {Number} endIndex\n     * @property {String} [value]\n     */\n\n    /**\n     * Scans the input string starting at the given index to determine the logic for a group.\n     * @param {String} input - The input string to parse into an array of tokens.\n     * @returns {Array.<ParserToken>}\n     * @private\n     */\n    static _tokenize(input) {\n        let tokens = [];\n        let openToken = null;\n        let isLogicalOr = /^OR|\\|\\|/i;\n        let isLogicalAnd = /^AND/i;\n        let isLogicalAndAlt = /^&&/i;\n        let sortedOpKeys = Filter.OP_KEYS.sort((a, b) => b.length - a.length); //ensure longest strings are checked first\n        for (let i = 0; i < input.length; i++) {\n            let newToken = null;\n            if (openToken && openToken.type === 'condition-value') { //parsing a value\n                if (!openToken.endIndex\n                    && (\n                        (openToken.style === 'double-quoted' && input[i - 1] !== '\\\\' && input[i] === '\"')\n                        || (openToken.style === 'single-quoted' && input[i - 1] !== '\\\\' && input[i] === '\\'')\n                        || (openToken.style === 'array' && input[i - 1] !== '\\\\' && input[i] === ']')\n                    )) {\n                    openToken.value += input[i]; //we include the quote (parsed out later)\n                    openToken.endIndex = i + 1;\n                    openToken = null;\n                } else if (!openToken.endIndex && openToken.style === 'naked' && NakedValueTokenTerminator.test(input[i])) {\n                    openToken.endIndex = i;\n                    openToken = null;\n                    i--; //need to walk back (-1) on this after closing as it may be a actionable char\n                } else if (!openToken.endIndex && openToken.style === 'naked' && input[i - 1] !== '\\\\' && input[i] === '\"') {\n                    throw new SyntaxError(`Failed to tokenize filter string, a conditional value at position ${openToken.startIndex} found a closing double-quote, but the value was not opened with one.`);\n                } else if (!openToken.endIndex && openToken.style === 'naked' && input[i - 1] !== '\\\\' && input[i] === '\\'') {\n                    throw new SyntaxError(`Failed to tokenize filter string, a conditional value at position ${openToken.startIndex} found a closing single-quote, but the value was not opened with one.`);\n                } else {\n                    openToken.value += input[i];\n                }\n            } else if (openToken && openToken.type === 'condition-property') { //parsing a property name\n                if (!openToken.endIndex && input[i] === '}') {\n                    openToken.endIndex = i + 1;\n                    openToken = null;\n                } else {\n                    openToken.value = (openToken.value ?? '') + input[i];\n                }\n            } else if (input[i] === '(') { //new group detected\n                newToken = {\n                    type: 'group-start',\n                    startIndex: i,\n                    endIndex: i + 1\n                };\n            } else if (input[i] === ')') { //new group detected\n                newToken = {\n                    type: 'group-end',\n                    startIndex: i,\n                    endIndex: i + 1\n                };\n            } else if (input[i] === '{') {\n                newToken = {\n                    type: 'condition-property',\n                    startIndex: i\n                };\n                openToken = newToken; //token is open for more information\n            } else if (isLogicalOr.test(input.substr(i, 2))) {\n                newToken = {\n                    type: 'group-logic',\n                    startIndex: i,\n                    endIndex: i + 2,\n                    value: Filter.LOGIC.OR\n                };\n                i += 1;\n            } else if (isLogicalAnd.test(input.substr(i, 3))) {\n                newToken = {\n                    type: 'group-logic',\n                    startIndex: i,\n                    endIndex: i + 3,\n                    value: Filter.LOGIC.AND\n                };\n                i += 2;\n            } else if (isLogicalAndAlt.test(input.substr(i, 2))) {\n                newToken = {\n                    type: 'group-logic',\n                    startIndex: i,\n                    endIndex: i + 2,\n                    value: Filter.LOGIC.AND\n                };\n                i += 1;\n            } else {\n                if (tokens.length && tokens[tokens.length - 1].type === 'condition-property') { //check for matching operator only if preceding was a conditional-property\n                    for (let op of sortedOpKeys) {\n                        if (input.substr(i, op.length)?.localeCompare(op, undefined, { sensitivity: 'base' }) === 0) {\n                            newToken = {\n                                type: 'condition-op',\n                                startIndex: i,\n                                endIndex: i + op.length,\n                                value: op\n                            };\n                            i += op.length - 1;\n                            break;\n                        }\n                    }\n                }\n                if (!newToken && /\\s/.test(input[i]) === false) { //check for a possible value starting\n                    //values should only be declared if the last token was a condition-op, validate this immediately.\n                    if (tokens.length && tokens[tokens.length - 1].type !== 'condition-op') {\n                        throw new SyntaxError(`Failed to tokenize filter string, an invalid or unexpected value was found at position ${i}.`);\n                    }\n                    newToken = {\n                        type: 'condition-value',\n                        startIndex: i,\n                        value: input[i],\n                        style: 'naked'\n                    };\n                    if (input[i - 1] !== '\\\\') { //ignore escaped values\n                        if (input[i] === '\"') {\n                            newToken.style = 'double-quoted';\n                        } else if (input[i] === '\\'') {\n                            newToken.style = 'single-quoted';\n                        } else if (input[i] === '[') {\n                            newToken.style = 'array';\n                        }\n                    }\n                    openToken = newToken; //token is open for more information\n                }\n            }\n            //push new token to array\n            if (newToken) {\n                tokens.push(newToken);\n            }\n        }\n        //validate\n        //ensure no open token\n        if (openToken) {\n            if (openToken.type === 'condition-property') {\n                throw new SyntaxError(`Failed to tokenize filter string, a conditional property at position ${openToken.startIndex} was not closed properly, expected matching square brackets \"[\" and \"]\".`);\n            } else if (openToken.type === 'condition-value' && openToken.style === 'double-quoted') {\n                throw new SyntaxError(`Failed to tokenize filter string, a conditional value at position ${openToken.startIndex} was not closed properly, a closing double-quote was not found.`);\n            } else if (openToken.type === 'condition-value' && openToken.style === 'single-quoted') {\n                throw new SyntaxError(`Failed to tokenize filter string, a conditional value token at position ${openToken.startIndex} was not closed properly, a closing single-quote was not found.`);\n            }\n        }\n        //ensure all groups are terminated\n        let groupStartCount = tokens.reduce((p, c) => c.type === 'group-start' ? p + 1 : p + 0, 0);\n        let groupEndCount = tokens.reduce((p, c) => c.type === 'group-end' ? p + 1 : p + 0, 0);\n        if (groupStartCount !== groupEndCount) {\n            throw new SyntaxError('Failed to tokenize filter string, there are one or more mismatches between the opening and closing group parenthesis \"(\" and \")\".');\n        }\n        //ensure all condition properties are followed by appropriate tokens\n        for (let ti = 0; ti < tokens.length; ti++) {\n            let t = tokens[ti];\n            if (t.type === 'condition-property') { //check followed by condition-op\n                if (ti === tokens.length - 1 || (ti < tokens.length - 1 && tokens[ti + 1].type !== 'condition-op')) {\n                    throw new SyntaxError(`Failed to tokenize filter string, a conditional property at position ${t.startIndex} was not followed by a conditional operator.`);\n                }\n            }\n        }\n        return tokens;\n    }\n\n    /**\n     * Parses a singlular supported string representation of a value into a typed value, either a Number, String, \n     * Date (from ISO8601, full), Boolean, or Array of those values. This method will remove outermost double or \n     * single quotes if found on a String value.\n     * @throws SyntaxError if there is an outermost starting or ending single or double quote without the opposite.\n     * @param {String} value - the value to be parsed.\n     * @returns {Number|String|Date|Boolean|Array}\n     * @private\n     */\n    static _parseValueString(value) {\n        if (value && typeof value === 'string') {\n            if (/^-?\\d*(\\.\\d+)?$/.test(value)) {\n                let tryValue = parseFloat(value);\n                if (isNaN(tryValue) === false) {\n                    return tryValue;\n                }\n            } else if (/^true$/i.test(value)) {\n                return true;\n            } else if (/^false$/i.test(value)) {\n                return false;\n            } else if (/^null$/i.test(value)) {\n                return null;\n            } else if (/^undefined$/i.test(value)) {\n                return undefined;\n            } else if (ISO8601Date.test(value)) {\n                return new Date(value);\n            } else if (/^(\"\"|'')$/.test(value)) { //empty string\n                return '';\n            } else if (/^\".+[^\\\\]\"$/.test(value)) {\n                return value.substr(1, value.length - 2).replace(/\\\\\"/g, '\"');\n            } else if (/^'.+[^\\\\]'$/.test(value)) {\n                return value.substr(1, value.length - 2).replace(/\\\\'/g, '\\'');\n            } else if (/^\".+([^\"]|\\\\\")$/.test(value) || /^([^\"]|\\\\\").+[^\\\\]\"$/.test(value)) {\n                throw new SyntaxError(`Error parsing filter value \"${value}\", unterminated double-quoted value.`);\n            } else if (/^'.+([^']|\\\\')$/.test(value) || /^([^']|\\\\').+[^\\\\]'$/.test(value)) {\n                throw new SyntaxError(`Error parsing filter value \"${value}\", unterminated single-quoted value.`);\n            } else if (/^\\[.*\\]$/.test(value)) {\n                let extract = [];\n                let isDoubleQuoted = false;\n                let isSingleQuoted = false;\n                for (let i = 1; i < value.length - 1; i++) {\n                    let append = false;\n                    if (isDoubleQuoted === false && isSingleQuoted === false && value[i] === ',') {\n                        if (extract.length === 0) {\n                            extract.push(null); //blank first item, set a null\n                        }\n                        extract.push(null); //create a space for the new item\n                    } else if (value[i - 1] !== '\\\\' && value[i] === '\"') {\n                        isDoubleQuoted = !isDoubleQuoted;\n                        append = true;\n                    } else if (value[i - 1] !== '\\\\' && value[i] === '\\'') {\n                        isSingleQuoted = !isSingleQuoted;\n                        append = true;\n                    } else if (/\\s/.test(value[i]) === false || extract[extract.length - 1]) {\n                        append = true;\n                    }\n                    if (append) {\n                        if (extract.length === 0) {\n                            extract.push(value[i]);\n                        } else {\n                            extract[extract.length - 1] = (extract[extract.length - 1] ?? '') + value[i];\n                        }\n                    }\n                }\n                //now parse each extracted array value\n                for (let i = 0; i < extract.length; i++) {\n                    extract[i] = Filter._parseValueString(extract[i]);\n                }\n                return extract;\n            }\n        }\n        return value;\n    }\n\n}\n\n/**\n * @readonly\n */\nFilter.LOGIC = {\n    AND: 'and',\n    OR: 'or'\n};\n\n/**\n * Array of valid logic strings.\n * @type {Array.<String>}\n */\nFilter.LOGIC_KEYS = Object.keys(Filter.LOGIC).map(k => Filter.LOGIC[k]);\n\n/**\n * @readonly\n */\nFilter.OP = {\n    EQUALS: 'eq',\n    NOTEQUALS: 'neq',\n    ISNULL: 'isnull',\n    ISNOTNULL: 'isnotnull',\n    LESSTHAN: 'lt',\n    LESSTHANOREQUAL: 'lte',\n    GREATERTHAN: 'gt',\n    GREATERTHANOREQUAL: 'gte',\n    STARTSWITH: 'startswith',\n    ENDSWITH: 'endswith',\n    CONTAINS: 'contains',\n    DOESNOTCONTAIN: 'doesnotcontain',\n    ISEMPTY: 'isempty',\n    ISNOTEMPTY: 'isnotempty',\n    IN: 'in',\n    NOTIN: 'nin'\n};\n\n/**\n * Array of valid conditional comparison strings.\n * @type {Array.<String>}\n */\nFilter.OP_KEYS = Object.keys(Filter.OP).map(k => Filter.OP[k]);\n\n/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (Filter);\n\n//# sourceURL=webpack://StashKu/./filter.js?");

/***/ }),

/***/ "./logger.js":
/*!*******************!*\
  !*** ./logger.js ***!
  \*******************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (__WEBPACK_DEFAULT_EXPORT__)\n/* harmony export */ });\n\n/**\n * @callback LoggerCallback\n * @param {String} state - Always a \"log\" string.\n * @param {String} severity - The severity level of the log message, either \"error\", \"warn\", \"info\", or \"debug\".\n * @param {Array} args - The log message arguments, this can be a mix of types.\n */\n\n/**\n * A logging interface class that exposes friendly log methods that pass information to a configured callback.\n */\nclass Logger {\n    /**\n     * Creates a new `Logger` instance.\n     * @param {LoggerCallback} callback - The logging callback asynchronously called when a log method call is made.\n     */\n    constructor(callback) {\n\n        /** @type {LoggerCallback} */\n        this.callback = callback || null;\n    }\n\n    /**\n     * Writes a debug-severity log message. This is the lowest severity.\n     * @param  {...any} args - Any object values to be logged.\n     */\n    async debug(...args) {\n        if (this.callback) {\n            await this.callback('log', 'debug', args);\n        }\n    }\n\n    /**\n     * Writes an information-severity log message. This is the second-to-lowest severity.\n     * @param  {...any} args - Any object values to be logged.\n     */\n    async info(...args) {\n        if (this.callback) {\n            await this.callback('log', 'info', args);\n        }\n    }\n\n    /**\n     * Writes a warning-severity log message. This is the second-to-highest severity.\n     * @param  {...any} args - Any object values to be logged.\n     */\n    async warn(...args) {\n        if (this.callback) {\n            await this.callback('log', 'warn', args);\n        }\n    }\n\n    /**\n     * Writes a error-severity log message. This is the highest severity.\n     * @param  {...any} args - Any object values to be logged.\n     */\n    async error(...args) {\n        if (this.callback) {\n            await this.callback('log', 'error', args);\n        }\n    }\n\n}\n\n/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (Logger);\n\n//# sourceURL=webpack://StashKu/./logger.js?");

/***/ }),

/***/ "./modeling/model-generator.js":
/*!*************************************!*\
  !*** ./modeling/model-generator.js ***!
  \*************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (__WEBPACK_DEFAULT_EXPORT__)\n/* harmony export */ });\n/* harmony import */ var _rest_error_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../rest-error.js */ \"./rest-error.js\");\n/* harmony import */ var _model_utility_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./model-utility.js */ \"./modeling/model-utility.js\");\n/* harmony import */ var _utilities_string_utility_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../utilities/string-utility.js */ \"./utilities/string-utility.js\");\n\n\n\n\n/**\n * A utility class for working with StashKu-compatible model objects.\n */\nclass ModelGenerator {\n\n    /**\n     * Attempts to format a generically formatted property name to a JavaScript camelCase property name format.\n     * @param {String} dirtyPropName - The property name value to be formatted.\n     * @returns {String}\n     */\n    static formatPropName(dirtyPropName) {\n        return _utilities_string_utility_js__WEBPACK_IMPORTED_MODULE_2__[\"default\"].camelify(dirtyPropName);\n    }\n\n    /**\n     * Attempts to format a generic resource name into a model class name in PascalCase format.\n     * The resource name is always suffixed with the word \"Model\".\n     * \n     * This function leverages the `STASHKU_MODEL_NAME_REMOVE` environmental setting, which allows you to configure\n     * one or more regular expressions that are removed from a generated model's class name (derived from a resource\n     * name). By default the configured expressions will strip \"dbo.\", \"etl.\", and \"rpt.\" prefixes from resource names.\n     * @param {String} dirtyResourceName - The resource name value to be formatted.\n     * @param {String} [suffix=\"Model\"] - A suffix attached to the model name. Defaults to \"Model\".\n     * @returns {String}\n     */\n    static formatModelName(dirtyResourceName, suffix = 'Model') {\n        let removes = ['/^\\\\[?dbo\\\\]?./i', '/^\\\\[?etl\\\\]?./i', '/^\\\\[?rpt\\\\]?./i'];\n        if (process.env.STASHKU_MODEL_NAME_REMOVE) {\n            removes = JSON.parse(process.env.STASHKU_MODEL_NAME_REMOVE);\n        }\n        if (removes && Array.isArray(removes)) {\n            for (let rStr of removes) {\n                let reg = _utilities_string_utility_js__WEBPACK_IMPORTED_MODULE_2__[\"default\"].toRegExp(rStr);\n                dirtyResourceName = dirtyResourceName.replace(reg, '');\n            }\n        }\n        dirtyResourceName = dirtyResourceName.replace(/[[\\]{}]/g, '');\n        return _utilities_string_utility_js__WEBPACK_IMPORTED_MODULE_2__[\"default\"].camelify(_utilities_string_utility_js__WEBPACK_IMPORTED_MODULE_2__[\"default\"].singular(dirtyResourceName), true) + (suffix ?? '');\n    }\n\n    /**\n     * Generates a model type class dynamically utilizing the given properties and configuration.\n     * \n     * @throws 500 `RESTError` if the \"typeName\" argument is missing.\n     * @throws 500 `RESTError` if the \"properties\" argument is missing.\n     * @throws 500 `RESTError` if the \"properties\" argument is not a Map instance.\n     * @param {String} resource - The name of the target resource.\n     * @param {Map.<String, Modeling.PropertyDefinition>} properties - The map of all properties definable for the model.\n     * @param {Modeling.Configuration} [configuration] - The $stashku model configuration.\n     * @param {String} [className] - Optional argument to utilize a specific class name instead of generating one \n     * from the resource name.\n     * @returns {Modeling.AnyModelType}\n     */\n    static generateModelType(resource, properties, configuration, className) {\n        if (!resource) {\n            throw new _rest_error_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"](500, 'The \"resource\" argument is required.');\n        } else if (!properties) {\n            throw new _rest_error_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"](500, 'The \"properties\" argument is required.');\n        } else if ((properties instanceof Map) === false) {\n            throw new _rest_error_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"](500, 'The \"properties\" argument must be of type Map.');\n        }\n        let sortedProperties = new Map();\n        //presort\n        properties = new Map([...properties.entries()].sort());\n        //pascal-case keys\n        for (let [k, v] of properties) {\n            let formattedKey = _utilities_string_utility_js__WEBPACK_IMPORTED_MODULE_2__[\"default\"].camelify(k, true);\n            if (formattedKey != k && sortedProperties.has(formattedKey) === false) {\n                sortedProperties.set(formattedKey, v);\n            } else {\n                sortedProperties.set(k, v);\n            }\n        }\n        //sort final\n        sortedProperties = new Map([...sortedProperties.entries()].sort());\n        //create model type closure\n        let mtConstructor = function () {\n            for (let [k, v] of sortedProperties) {\n                let typeOfValue = typeof v;\n                if (v === null || typeOfValue === 'undefined') {\n                    this[k] = null;\n                } else if (typeOfValue === 'object') {\n                    this[k] = typeof v.default !== 'undefined' ? v.default : null;\n                }\n            }\n        };\n        let mt = class DynamicModel {\n            constructor() { mtConstructor.call(this); }\n        };\n        if (!className) {\n            className = ModelGenerator.formatModelName(resource);\n        }\n        Object.defineProperty(mt, 'name', { value: className });\n        //add json stringification support\n        let toSchema = _model_utility_js__WEBPACK_IMPORTED_MODULE_1__[\"default\"].schema;\n        mt.toJSON = (function() {\n            return toSchema(this);\n        }).bind(mt);\n        //add static properties\n        for (let [k, v] of sortedProperties) {\n            if (v === null || typeof v === 'undefined') {\n                mt[k] = {};\n            } else {\n                mt[k] = v;\n            }\n        }\n        //add $stashku configuration static property\n        if (!configuration) {\n            mt.$stashku = {};\n        } else {\n            mt.$stashku = configuration;\n        }\n        //add helper names to configration if missing\n        if (!mt.$stashku.resource) {\n            mt.$stashku.resource = resource;\n        }\n        if (!mt.$stashku.name) {\n            mt.$stashku.name = ModelGenerator.formatModelName(resource, '');\n        }\n        if (!mt.$stashku.slug) {\n            mt.$stashku.slug = _utilities_string_utility_js__WEBPACK_IMPORTED_MODULE_2__[\"default\"].slugify(mt.$stashku.name, '-', true, true);\n        }\n        if (!mt.$stashku.plural) {\n            mt.$stashku.plural = {};\n        }\n        if (!mt.$stashku.plural.name) {\n            mt.$stashku.plural.name = _utilities_string_utility_js__WEBPACK_IMPORTED_MODULE_2__[\"default\"].camelify(_utilities_string_utility_js__WEBPACK_IMPORTED_MODULE_2__[\"default\"].plural(mt.$stashku.name), true);\n        }\n        if (!mt.$stashku.plural.slug) {\n            mt.$stashku.plural.slug = _utilities_string_utility_js__WEBPACK_IMPORTED_MODULE_2__[\"default\"].slugify(mt.$stashku.plural.name, '-', true, true);\n        }\n        return mt;\n    }\n\n}\n\n/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (ModelGenerator);\n\n\n//# sourceURL=webpack://StashKu/./modeling/model-generator.js?");

/***/ }),

/***/ "./modeling/model-utility.js":
/*!***********************************!*\
  !*** ./modeling/model-utility.js ***!
  \***********************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (__WEBPACK_DEFAULT_EXPORT__)\n/* harmony export */ });\n/* harmony import */ var _utilities_string_utility_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../utilities/string-utility.js */ \"./utilities/string-utility.js\");\n/* harmony import */ var _rest_error_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../rest-error.js */ \"./rest-error.js\");\n///<reference path=\"./modeling.d.js\" />\n\n\n\n/**\n * A utility class for working with StashKu-compatible model objects.\n */\nclass ModelUtility {\n\n    /**\n     * Returns `true` if the model type object provided appears to be a class or constructor function, otherwise a\n     * `false` value is returned.\n     * @param {Modeling.AnyModelType} modelType - The model \"class\" or constructor function to be checked.\n     * @returns {Boolean}\n     */\n    static isValidType(modelType) {\n        return !!(modelType && modelType.constructor && modelType.prototype);\n    }\n\n    /**\n     * Returns a map of modeled properties (keys) and their definitions (values). The value is a property definition\n     * that details how the modeled property maps to the underlying storage, including the actual storage `target`.\n     * @param {Modeling.AnyModelType} modelType - The model \"class\" or constructor function.\n     * @returns {Map.<String, Modeling.PropertyDefinition>}\n     */\n    static map(modelType) {\n        let propMap = new Map();\n        if (ModelUtility.isValidType(modelType)) {\n            while (modelType) {\n                let descriptors = Object.getOwnPropertyDescriptors(modelType);\n                //get static \"get\" property names that are readable and writable or plain values.\n                for (let prop in descriptors) {\n                    if (prop !== '$stashku' && prop !== 'prototype' && prop != '__proto' && prop != 'toJSON') {\n                        let desc = descriptors[prop];\n                        if (desc.enumerable || desc.get) {\n                            let propDefinition = null;\n                            let input = modelType[prop];\n                            let inputType = typeof input;\n                            if (inputType === 'function') {\n                                input = input(modelType, prop);\n                                inputType = typeof input;\n                            }\n                            if (inputType === 'string') {\n                                propDefinition = { target: input };\n                            } else if (inputType === 'object') {\n                                propDefinition = input;\n                                if (!propDefinition.target) {\n                                    //ensure a name is set on the definition object\n                                    propDefinition.target = prop;\n                                }\n                            }\n                            if (propDefinition && propMap.has(prop) === false) {\n                                propMap.set(prop, propDefinition);\n                            }\n                        }\n                    }\n                }\n                let proto = Object.getPrototypeOf(modelType);\n                if (proto && proto.name && proto.prototype !== undefined) {\n                    modelType = proto;\n                } else {\n                    modelType = null;\n                }\n            }\n        }\n        return propMap;\n    }\n\n    /**\n     * Takes a model type and generates an object with the same properties used to define the model - all\n     * property definitions and the `$stashku` configuration. If the `$stashku` property is not found it is generated\n     * with a `resource` property and derived value.\n     * @throws 500 `RESTError` if the \"modelType\" argument is missing or not a supported StashKu model type object.\n     * @param {Modeling.AnyModelType} modelType - The model \"class\" or constructor function.\n     * @returns {*}\n     */\n    static schema(modelType) {\n        if (ModelUtility.isValidType(modelType) === false) {\n            throw new _rest_error_js__WEBPACK_IMPORTED_MODULE_1__[\"default\"](500, 'The \"modelType\" argument is required and must be a supported StashKu model type object.');\n        }\n        let schema = {};\n        let mapping = ModelUtility.map(modelType);\n        for (let [p, pDef] of mapping) {\n            schema[p] = pDef;\n        }\n        if (typeof modelType.$stashku === 'object') {\n            schema.$stashku = modelType.$stashku;\n        } else {\n            schema.$stashku = { resource: ModelUtility.resource(modelType) };\n        }\n        return schema;\n    }\n\n    /**\n     * Returns the StashKu resource name for the given model, if specified. Optionally checks for a specific action\n     * name configuration and uses it if specified. If the resource is a function, it is called with and the return\n     * value is returned as the resource name.\n     * \n     * If a `resource` static property is not available on the model's `$stashku` property, the model constructor\n     * name is used instead.\n     * @param {Modeling.AnyModelType} modelType - The model \"class\" or constructor function.\n     * @param {String} [method] - The name of the method that should override the default value if it is explicitly\n     * specified. If it is not found, but an `all` or `'*'` property is found, it is used instead.\n     * @param {String} [resourceProp=\"resource\"] - The resource property used from the model type to set the resource on\n     * this request.\n     * @returns {String}\n     */\n    static resource(modelType, method, resourceProp = 'resource') {\n        if (ModelUtility.isValidType(modelType)) {\n            if (modelType.$stashku && modelType.$stashku.resource) {\n                let resource =  modelType.$stashku.resource;\n                switch (resourceProp) {\n                    case 'name': resource = modelType.$stashku.name; break;\n                    case 'slug': resource = modelType.$stashku.slug; break;\n                    case 'plural.name': resource = modelType.$stashku.plural.name; break;\n                    case 'plural.slug': resource = modelType.$stashku.plural.slug; break;\n                }\n                let resType = typeof resource;\n                if (resType === 'string') {\n                    return resource;\n                } else if (resType === 'object') {\n                    let hasAction = (typeof resource[method] !== 'undefined');\n                    if (hasAction === false) {\n                        //action not present, so lookf for a default fallback.\n                        if (typeof resource['all'] !== 'undefined') {\n                            method = 'all';\n                        } else if (typeof resource['*'] !== 'undefined') {\n                            method = '*';\n                        } else {\n                            return null;\n                        }\n                    }\n                    //looks like a custom object with the action.\n                    resType = typeof resource[method];\n                    if (resType === 'string') {\n                        return resource[method];\n                    }\n                }\n                //fallback to null if resource is present but no valid match\n            } else {\n                //no resource property, so default to the class/constructor name pluralized\n                return _utilities_string_utility_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"].plural(modelType.name) || null;\n            }\n        }\n        return null;\n    }\n\n    /**\n     * Returns the \"primary key\" property names as specified on a model configuration type.\n     * @param {Modeling.AnyModelType} modelType - The model \"class\" or constructor function.\n     * @returns {Array.<String>}\n     */\n    static pk(modelType) {\n        let primaryKeys = [];\n        if (ModelUtility.isValidType(modelType)) {\n            let mapping = ModelUtility.map(modelType);\n            for (let [_, v] of mapping) {\n                if (v && v.pk) {\n                    primaryKeys.push(v.target);\n                }\n            }\n        }\n        return primaryKeys;\n    }\n\n    /**\n     * @template T\n     * @typedef {new(...args: Array) | new(...args: Array) => T} Constructor\n     **/\n\n    /**\n     * Use a given model type to to convert the given storage object(s) into a model (instance) of the specified model \n     * type. If a property is not mapped in the model, the property (and value) will *not* be assigned to the model.\n     * \n     * This method is called by StashKu after a response is returned by the underlying engine (and a model is being\n     * used) but before it is handed back to the caller.\n     * @throws 500 `RESTError` if the \"modelType\" argument is missing or not a supported StashKu model type object.\n     * @throws 500 `RESTError` if the \"method\" argument is missing or not a string.\n     * @template T\n     * @param {T} modelType - The model \"class\" or constructor function.\n     * @param {String} method - The method of the request being processed, typically: \"get\", \"post\", \"put\", \"patch\",\n     * \"delete\", or \"options\".\n     * @param  {...any} objects - The raw objects to be transmuted into a model.\n     * @yields {Constructor.<T>}\n     * @generator\n     */\n    static * model(modelType, method, ...objects) {\n        if (ModelUtility.isValidType(modelType) === false) {\n            throw new _rest_error_js__WEBPACK_IMPORTED_MODULE_1__[\"default\"](500, 'The \"modelType\" argument is required and must be a supported StashKu model type object.');\n        } else if (!method || typeof method !== 'string') {\n            throw new _rest_error_js__WEBPACK_IMPORTED_MODULE_1__[\"default\"](500, 'The \"method\" argument is required and must be a string.');\n        }\n        let mapping = ModelUtility.map(modelType);\n        for (let obj of objects) {\n            if (obj) {\n                if (obj instanceof modelType) {\n                    yield obj; //nothing to do, already modelType\n                } else {\n                    let model = new modelType();\n                    for (let [k, v] of mapping) {\n                        if (typeof obj[v.target] !== 'undefined') {\n                            model[k] = obj[v.target];\n                        } else if (typeof v.default === 'undefined') {\n                            //not given by input object, and no default defined- nuke property from model instance.\n                            delete model[k];\n                        }\n                        if (v.transform) { //run a transform if present.\n                            model[k] = v.transform.call(modelType, k, model[k], obj, method, 'model');\n                        }\n                        if (v.omit && typeof model[k] !== 'undefined') { //omit the property if warranted\n                            let omitted = (v.omit === true);\n                            if (typeof v.omit === 'function') {\n                                omitted = v.omit.call(modelType, k, model[k], obj, method, 'model');\n                            } else if (v.omit === null && model[k] === null) {\n                                omitted = true;\n                            } else if (typeof v.omit === 'object') {\n                                if (v.omit[method] === true) {\n                                    omitted = true;\n                                } else if (typeof v.omit[method] === 'function') {\n                                    omitted = v.omit[method].call(modelType, k, model[k], obj, method, 'model');\n                                } else if (v.omit[method] === null && model[k] === null) {\n                                    omitted = true;\n                                } else if (v.omit.all === true && v.omit[method] !== false) {\n                                    omitted = true;\n                                }\n                            }\n                            if (omitted === true) {\n                                delete model[k];\n                            }\n                        }\n                    }\n                    yield model;\n                }\n            } else {\n                yield null;\n            }\n        }\n    }\n\n    /**\n     * Use a specified model type to revert models back to a regular (untyped) object.\n     * \n     * Certain StashKu requests will call this automatically before the request is sent to the underlying engine.    \n     * A PATCH request will attempt to unmodel it's template.    \n     * A PUT & POST request will attempt to unmodel it's objects.\n     * @throws 500 `RESTError` if the \"modelType\" argument is missing or not a supported StashKu model type object.\n     * @throws 500 `RESTError` if the \"method\" argument is missing or not a string.\n     * @template T\n     * @param {T} modelType - The model \"class\" or constructor function.\n     * @param {String} method - The method of the request being processed, typically: \"get\", \"post\", \"put\", \"patch\",\n     * \"delete\", or \"options\".\n     * @param  {...Constructor.<T>} models - The modeled objects to be transformed back into a storage object.\n     * @yields {Constructor.<T>}\n     * @generator\n     */\n    static * unmodel(modelType, method, ...models) {\n        if (ModelUtility.isValidType(modelType) === false) {\n            throw new _rest_error_js__WEBPACK_IMPORTED_MODULE_1__[\"default\"](500, 'The \"modelType\" argument is required and must be a supported StashKu model type object.');\n        } else if (!method || typeof method !== 'string') {\n            throw new _rest_error_js__WEBPACK_IMPORTED_MODULE_1__[\"default\"](500, 'The \"method\" argument is required and must be a string.');\n        }\n        let mapping = ModelUtility.map(modelType);\n        for (let model of models) {\n            if (model) {\n                if (model instanceof modelType) {\n                    let record = {};\n                    for (let [k, v] of mapping) {\n                        if (typeof model[k] !== 'undefined') { //only set a value if the property value is defined.\n                            record[v.target] = model[k]; \n                        }\n                        if (v && v.transform) { //run a transform if present.\n                            record[v.target] = v.transform.call(modelType, v.target, record[v.target], model, method, 'unmodel');\n                        }\n                        if (v && v.omit) { //omit the property if warranted\n                            let omitted = (v.omit === true);\n                            if (typeof v.omit === 'function') {\n                                omitted = v.omit.call(modelType, k, model[k], model, method, 'model');\n                            } else if (v.omit === null && model[k] === null) {\n                                omitted = true;\n                            } else if (typeof v.omit === 'object') {\n                                if (v.omit[method] === true) {\n                                    omitted = true;\n                                } else if (typeof v.omit[method] === 'function') {\n                                    omitted = v.omit[method].call(modelType, k, model[k], model, method, 'model');\n                                } else if (v.omit[method] === null && model[k] === null) {\n                                    omitted = true;\n                                } else if (v.omit.all === true && v.omit[method] !== false) {\n                                    omitted = true;\n                                }\n                            }\n                            if (omitted === true) {\n                                delete record[v.target];\n                            }\n                        }\n                    }\n                    yield record;\n                } else {\n                    yield model; //nothing to do, already not a modelType.\n                }\n            } else {\n                yield null;\n            }\n        }\n    }\n\n}\n\n/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (ModelUtility);\n\n//# sourceURL=webpack://StashKu/./modeling/model-utility.js?");

/***/ }),

/***/ "./requests/delete-request.js":
/*!************************************!*\
  !*** ./requests/delete-request.js ***!
  \************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (__WEBPACK_DEFAULT_EXPORT__)\n/* harmony export */ });\n/* harmony import */ var _filter_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../filter.js */ \"./filter.js\");\n/* harmony import */ var _modeling_model_utility_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../modeling/model-utility.js */ \"./modeling/model-utility.js\");\n\n\n\n/**\n * This class defines a StashKu DELETE request that instructs StashKu to delete objects matching the specified criteria.\n */\nclass DeleteRequest {\n    /**\n     * Creates a new `DeleteRequest` instance. A DELETE request instructs StashKu to delete objects from storage that\n     * match the specified criteria.\n     */\n    constructor() {\n        this.metadata = {\n            /** @type {Boolean} */\n            all: false,\n            /** @type {Filter} */\n            where: null,\n            /** @type {String} */\n            from: null,\n            /** @type {Boolean} */\n            count: false,\n            /** @type {Map.<String, *>} */\n            headers: null\n        };\n    }\n\n    /**\n     * @type {String}\n     */\n    get method() {\n        return 'delete';\n    }\n\n    /**\n     * Applies a StahKu-compatible model's metadata & configuration *not already defined* to this request.\n     * \n     * If a `null` value is passed, the model is removed - but metadata on the request will remain.\n     * @throws Error when the `modelType` argument is not `null`, a class, or a constructor object.\n     * @param {Modeling.AnyModelType} modelType - The model \"class\" or constructor function.\n     * @param {Boolean} [overwrite = false] - Optional flag that, when `true`, overwrites request settings and values\n     * with the model's (where applicable).\n     * @param {String} [resourceProp=\"resource\"] - The resource property used from the model type to set the resource on\n     * this request.\n     * @returns {DeleteRequest}\n     * @private\n     */\n    model(modelType, overwrite = false, resourceProp = 'resource') {\n        if (modelType !== null && _modeling_model_utility_js__WEBPACK_IMPORTED_MODULE_1__[\"default\"].isValidType(modelType) === false) {\n            throw new Error('Invalid \"modelType\" argument. The value must be null, a class, or a constructor object');\n        }\n        if (modelType) {\n            if (overwrite === true || !this.metadata.from) {\n                this.from(_modeling_model_utility_js__WEBPACK_IMPORTED_MODULE_1__[\"default\"].resource(modelType, this.method, resourceProp));\n            }\n        }\n        return this;\n    }\n\n    /**\n     * Requests that the response return count numbers (total, affected, returned, etc.) but not objects.\n     * \n     * This will result in a `Response` with an empty `data` array and may result in faster query execution if you\n     * only need the resulting numbers.\n     * \n     * Calling this function without an argument *enables* the flag.\n     * @param {Boolean} [enabled=true] - A `true` enables the count-only result. A `false` disables it.\n     * @returns {GetRequest}\n     */\n    count(enabled) {\n        if (typeof enabled === 'undefined') {\n            this.metadata.count = true;\n        } else {\n            this.metadata.count = !!enabled;\n        }\n        return this;\n    }\n\n    /**\n     * Enables the deletion of all objects in data storage if no `where` conditions are specified. If conditions are\n     * specified, this setting will be ignored.\n     * \n     * Caling this method without an argument will set the request to *enable* the update of all objects.\n     * @param {Boolean} enabled - Enable or disable the deletion of all records.\n     * @returns {DeleteRequest}\n     */\n    all(enabled) {\n        if (arguments.length === 0) {\n            enabled = true;\n        }\n        this.metadata.all = !!enabled;\n        return this;\n    }\n\n    /**\n     * @callback ConditionCallback\n     * @param {Filter} f\n     */\n\n    /**\n     * Creates a set of conditions on the request to match specific objects in storage.    \n     * Any existing where conditions will be overwritten.    \n     * If a `null` value is passed, the where conditions are cleared.\n     * @throws Error if the \"conditions\" argument must be null or a Filter instance.\n     * @param {Filter|ConditionCallback} conditions - The conditions to be used to filter out results.\n     * @returns {DeleteRequest}\n     */\n    where(conditions) {\n        if (conditions === null) {\n            this.metadata.where = null;\n            return this;\n        } else if (conditions instanceof _filter_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"]) {\n            this.metadata.where = conditions;\n        } else if (typeof conditions === 'string') {\n            this.metadata.where = _filter_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"].parse(conditions);\n        } else if (typeof conditions === 'function') {\n            this.metadata.where = new _filter_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"]();\n            conditions(this.metadata.where);\n        } else {\n            throw new Error('The \"conditions\" argument must be null, a callback, or a Filter instance.');\n        }\n        return this;\n    }\n\n    /**\n     * Sets the target resource name for the request, optionally specifying an alias for use with specifying properties\n     * across joins.\n     * \n     * @throws Error if the \"name\" argument value is not a string or null.\n     * @param {String} name - The name of the target resource in data storage.\n     * @returns {DeleteRequest}\n     */\n    from(name) {\n        if (name !== null && typeof name !== 'string') {\n            throw new Error('Invalid \"name\" argument. The value must be a string or null.');\n        }\n        this.metadata.from = name;\n        return this;\n    }\n\n    /**\n     * Clears all configured metadata on the request, resetting it to a default state.\n     * @returns {DeleteRequest}\n     */\n    clear() {\n        if (!this.metadata) {\n            this.metadata = {};\n        }\n        this.metadata.all = false;\n        this.metadata.where = null;\n        this.metadata.from = null;\n        this.metadata.headers = null;\n        return this;\n    }\n\n    /**\n     * Sets or clears headers on the request that can be used to set engine-specific options for the request.\n     * If a `null` value is passed, the headers are cleared.\n     * @throws Error when the dictionary argument uses a non-string key.\n     * @throws Error when the dictionary argument is not an object, null, or a Map.\n     * @param {Object | Map.<String, *>} dictionary - A map or object defining the headers and values.\n     * @returns {DeleteRequest}\n     */\n    headers(dictionary) {\n        if (!this.metadata.headers) {\n            this.metadata.headers = new Map();\n        }\n        if (dictionary === null) {\n            this.metadata.headers.clear();\n        } else if (dictionary instanceof Map || typeof dictionary === 'object') {\n            let iterable = dictionary;\n            if ((dictionary instanceof Map) === false) {\n                iterable = Object.entries(dictionary);\n            }\n            for (let [k, v] of iterable) {\n                if (k !== null && typeof k !== 'undefined') {\n                    if (typeof k !== 'string') {\n                        throw new Error('An invalid non-string key value was provided in the \"dictionary\" argument. Only string-based keys may be used.');\n                    }\n                    if (v === null || typeof v === 'undefined') {\n                        this.metadata.headers.delete(k);\n                    } else {\n                        this.metadata.headers.set(k, v);\n                    }\n                }\n            }\n        } else {\n            throw new Error('The \"dictionary\" argument must be null, a Map, or an object.');\n        }\n        return this;\n    }\n\n    /**\n     * Returns the metadata object to be utilized for stringifying into JSON.\n     * @returns {*}\n     * @protected\n     */\n    toJSON() {\n        let metaClone = { from: this.metadata.from };\n        if (this.metadata.headers) {\n            metaClone.headers = Object.fromEntries(this.metadata.headers);\n        }\n        if (this.metadata.all) {\n            metaClone.all = this.metadata.all;\n        }\n        if (this.metadata.count) {\n            metaClone.count = this.metadata.count;\n        }\n        if (this.metadata.where && _filter_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"].isEmpty(this.metadata.where) === false) {\n            metaClone.where = this.metadata.where.toJSON();\n        }\n        return metaClone;\n    }\n\n}\n\nconst STANDARD_METADATA = ['all', 'where', 'from', 'count', 'headers'];\n\n/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (DeleteRequest);\n\n//# sourceURL=webpack://StashKu/./requests/delete-request.js?");

/***/ }),

/***/ "./requests/get-request.js":
/*!*********************************!*\
  !*** ./requests/get-request.js ***!
  \*********************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (__WEBPACK_DEFAULT_EXPORT__)\n/* harmony export */ });\n/* harmony import */ var _filter_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../filter.js */ \"./filter.js\");\n/* harmony import */ var _sort_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../sort.js */ \"./sort.js\");\n/* harmony import */ var _modeling_model_utility_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../modeling/model-utility.js */ \"./modeling/model-utility.js\");\n///<reference path=\"../modeling/modeling.d.js\" />\n\n\n\n\n/**\n * This class defines a StashKu GET request that instructs StashKu to retrieve objects from storage.\n */\nclass GetRequest {\n    /**\n     * Creates a new `PostRequest` instance. A GET request instructs StashKu to retrieve objects from storage.\n     * @param  {...String} [properties] - Spread of field names (aka: columns) to get from data storage.\n     */\n    constructor(...properties) {\n        this.metadata = {\n            /** @type {Array.<String>} */\n            properties: [],\n            /** @type {Filter} */\n            where: null,\n            /** @type {Array.<Sort>} */\n            sorts: [],\n            /** @type {String} */\n            from: null,\n            /** @type {Number} */\n            take: 0,\n            /** @type {Number} */\n            skip: 0,\n            /** @type {Boolean} */\n            distinct: false,\n            /** @type {Boolean} */\n            count: false,\n            /** @type {Map.<String, *>} */\n            headers: null\n        };\n        this.properties(...properties);\n    }\n\n    /**\n     * @type {String}\n     */\n    get method() {\n        return 'get';\n    }\n\n    /**\n     * Applies a StahKu-compatible model's metadata & configuration *not already defined* to this request.\n     * \n     * If a `null` value is passed, the model is removed - but metadata on the request will remain.\n     * @throws Error when the `modelType` argument is not `null`, a class, or a constructor object.\n     * @param {Modeling.AnyModelType} modelType - The model \"class\" or constructor function.\n     * @param {Boolean} [overwrite = false] - Optional flag that, when `true`, overwrites request settings and values\n     * with the model's (where applicable).\n     * @param {String} [resourceProp=\"resource\"] - The resource property used from the model type to set the resource on\n     * this request.\n     * @returns {GetRequest}\n     * @private\n     */\n    model(modelType, overwrite = false, resourceProp = 'resource') {\n        if (modelType !== null && _modeling_model_utility_js__WEBPACK_IMPORTED_MODULE_2__[\"default\"].isValidType(modelType) === false) {\n            throw new Error('Invalid \"modelType\" argument. The value must be null, a class, or a constructor object');\n        }\n        if (modelType) {\n            if (overwrite === true || !this.metadata.from) {\n                this.from(_modeling_model_utility_js__WEBPACK_IMPORTED_MODULE_2__[\"default\"].resource(modelType, this.method, resourceProp));\n            }\n            if (overwrite === true || !this.metadata.properties || this.metadata.properties.length === 0) {\n                let targets = [];\n                for (let v of _modeling_model_utility_js__WEBPACK_IMPORTED_MODULE_2__[\"default\"].map(modelType).values()) {\n                    targets.push(v.target);\n                }\n                this.properties(...targets);\n            }\n        }\n        return this;\n    }\n\n    /**\n     * Requests that the retrieved results be distinct among the selected (or all) properties.    \n     * Calling this function without an argument *enables* the flag.\n     * @param {Boolean} [enabled=true] - A `true` enables the distinct results. A `false` disables it.\n     * @returns {GetRequest}\n     */\n    distinct(enabled) {\n        if (typeof enabled === 'undefined') {\n            this.metadata.distinct = true;\n        } else {\n            this.metadata.distinct = !!enabled;\n        }\n        return this;\n    }\n\n    /**\n     * Requests that the response return count numbers (total, affected, returned, etc.) but not objects.\n     * \n     * This will result in a `Response` with an empty `data` array and may result in faster query execution if you\n     * only need the resulting numbers.\n     * \n     * Calling this function without an argument *enables* the flag.\n     * @param {Boolean} [enabled=true] - A `true` enables the count-only result. A `false` disables it.\n     * @returns {GetRequest}\n     */\n    count(enabled) {\n        if (typeof enabled === 'undefined') {\n            this.metadata.count = true;\n        } else {\n            this.metadata.count = !!enabled;\n        }\n        return this;\n    }\n\n    /**\n     * Adds properties to the GET request. If the property is already present, it is ignored.    \n     * If a `null` value is passed, all properties are cleared from the request.\n     * @param  {...String|Modeling.PropertyDefinition} [properties] - Spread of property names (aka: columns) to get from data storage.\n     * @returns {GetRequest}\n     */\n    properties(...properties) {\n        if (Array.isArray(this.metadata.properties) === false) {\n            this.metadata.properties = [];\n        }\n        if (!properties || (properties.length === 1 && properties[0] === null)) {\n            this.metadata.properties = [];\n        } else {\n            for (let f of properties) {\n                let prop = f;\n                if (f.target && typeof f.target === 'string') {\n                    prop = f.target;\n                }\n                if (typeof prop !== 'string') {\n                    throw new Error('Invalid \"properties\" argument. The array contains a non-string value.');\n                }\n                if (this.metadata.properties.some(v => v === prop) == false) {\n                    this.metadata.properties.push(prop);\n                }\n            }\n        }\n        return this;\n    }\n\n    /**\n     * @callback ConditionCallback\n     * @param {Filter} f\n     */\n\n    /**\n     * Creates a set of conditions on the request to match specific objects in storage.    \n     * Any existing where conditions will be overwritten.    \n     * If a `null` value is passed, the where conditions are cleared.\n     * @throws Error if the \"conditions\" argument must be null or a Filter instance.\n     * @param {Filter|ConditionCallback} conditions - The conditions to be used to filter out results.\n     * @returns {GetRequest}\n     */\n    where(conditions) {\n        if (conditions === null) {\n            this.metadata.where = null;\n            return this;\n        } else if (conditions instanceof _filter_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"]) {\n            this.metadata.where = conditions;\n        } else if (typeof conditions === 'string') {\n            this.metadata.where = _filter_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"].parse(conditions);\n        } else if (typeof conditions === 'function') {\n            this.metadata.where = new _filter_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"]();\n            conditions(this.metadata.where);\n        } else {\n            throw new Error('The \"conditions\" argument must be null, a callback, or a Filter instance.');\n        }\n        return this;\n    }\n\n    /**\n     * Adds sort criteria to the GET request. If the sort is already present, it is updated.    \n     * If a `null` value is passed, all sorts are removed.\n     * \n     * @throws Error if the any `sorts` argument value is not a string, Sort, null, or undefined.\n     * @throws Error if the any `sorts` argument property is a blank string.\n     * @param  {...Sort} [sorts] - Spread of sorts which describe the order of results.\n     * @returns {GetRequest}\n     */\n    sort(...sorts) {\n        if (Array.isArray(this.metadata.sorts) === false) {\n            this.metadata.sorts = [];\n        }\n        if (!sorts || (sorts.length === 1 && sorts[0] === null)) {\n            this.metadata.sorts = [];\n        } else {\n            sorts = sorts.flat();\n            for (let s of sorts) {\n                let stype = typeof s;\n                if (s !== null && stype !== 'undefined') {\n                    if ((s instanceof _sort_js__WEBPACK_IMPORTED_MODULE_1__[\"default\"]) === false) {\n                        if (stype === 'string') {\n                            if (s.match(/{.+}/)) {\n                                s = _sort_js__WEBPACK_IMPORTED_MODULE_1__[\"default\"].parse(s);\n                            } else {\n                                s = _sort_js__WEBPACK_IMPORTED_MODULE_1__[\"default\"].asc(s);\n                            }\n                        } else if (s.property) {\n                            s = new _sort_js__WEBPACK_IMPORTED_MODULE_1__[\"default\"](s.property, s.dir);\n                        } else if (s.field) {\n                            s = new _sort_js__WEBPACK_IMPORTED_MODULE_1__[\"default\"](s.field, s.dir);\n                        } else {\n                            throw new Error('The \"sorts\" argument contains an invalid value. Values must be a string, Sort, null, or undefined.');\n                        }\n                    }\n                    if (s.property) {\n                        let existingIndex = this.metadata.sorts.findIndex(v => v.property.toLowerCase() === s.property.toLowerCase());\n                        if (existingIndex >= 0) {\n                            //remove existing from the array to it's order is reset when it is re-added.\n                            this.metadata.sorts.splice(existingIndex, 1);\n                        }\n                        this.metadata.sorts.push(s);\n                    }\n                }\n            }\n        }\n        return this;\n    }\n\n    /**\n     * Sets the target resource name for the request, optionally specifying an alias for use with specifying properties\n     * across joins.\n     * \n     * @throws Error if the \"name\" argument value is not a string or null.\n     * @param {String} name - The name of the target resource in data storage.\n     * @returns {GetRequest}\n     */\n    from(name) {\n        if (name !== null && typeof name !== 'string') {\n            throw new Error('Invalid \"name\" argument. The value must be a string or null.');\n        }\n        this.metadata.from = name;\n        return this;\n    }\n\n    /**\n     * Indicates the request wishes to skip over the specified number of objects in storage.\n     * @param {Number|String} count - The number of models to skip over. Optionally, if the string `\"all\"` is provided,\n     * then the `skip` and `take` values will be cleared.\n     * @returns {GetRequest}\n     */\n    skip(count) {\n        if (typeof count === 'undefined') {\n            return this;\n        } else if (count === null) {\n            count = 0;\n        } else if (count === 'all') {\n            count = 0;\n            this.metadata.take = 0;\n        } else if (isNaN(count) || count < 0) {\n            throw new Error('The \"count\" argument is invalid. The value must be a number.');\n        }\n        this.metadata.skip = parseInt(count) || 0;\n        return this;\n    }\n\n    /**\n     * Indicates only one object should be returned. This is equivalent to calling `take(1)`.\n     * @returns {GetRequest}\n     */\n    one() {\n        return this.take(1);\n    }\n\n    /**\n     * Hints that the request wishes to retrieve only the specified number of objects from storage.\n     * @param {Number|String} count - The number of models to take. Optionally, if the string `\"all\"` is provided, then\n     * the `skip` and `take` values will be cleared.\n     * @returns {GetRequest}\n     */\n    take(count) {\n        if (typeof count === 'undefined') {\n            return this;\n        } else if (count === null) {\n            count = 0;\n        } else if (count === 'all') {\n            count = 0;\n            this.metadata.skip = 0;\n        } else if (isNaN(count) || count < 0) {\n            throw new Error('The \"count\" argument is invalid. The value must be a number.');\n        }\n        this.metadata.take = parseInt(count) || 0;\n        return this;\n    }\n\n    /**\n     * Clears all configured metadata on the request, resetting it to a default state.\n     * @returns {GetRequest}\n     */\n    clear() {\n        if (!this.metadata) {\n            this.metadata = {};\n        }\n        this.metadata.properties = [];\n        this.metadata.where = null;\n        this.metadata.sorts = [];\n        this.metadata.from = null;\n        this.metadata.skip = 0;\n        this.metadata.take = 0;\n        this.metadata.headers = null;\n        return this;\n    }\n\n    /**\n     * Sets or clears headers on the request that can be used to set engine-specific options for the request.\n     * If a `null` value is passed, the headers are cleared.\n     * @throws Error when the dictionary argument uses a non-string key.\n     * @throws Error when the dictionary argument is not an object, null, or a Map.\n     * @param {Object | Map.<String, *>} dictionary - A map or object defining the headers and values.\n     * @returns {GetRequest}\n     */\n    headers(dictionary) {\n        if (!this.metadata.headers) {\n            this.metadata.headers = new Map();\n        }\n        if (dictionary === null) {\n            this.metadata.headers.clear();\n        } else if (dictionary instanceof Map || typeof dictionary === 'object') {\n            let iterable = dictionary;\n            if ((dictionary instanceof Map) === false) {\n                iterable = Object.entries(dictionary);\n            }\n            for (let [k, v] of iterable) {\n                if (k !== null && typeof k !== 'undefined') {\n                    if (typeof k !== 'string') {\n                        throw new Error('An invalid non-string key value was provided in the \"dictionary\" argument. Only string-based keys may be used.');\n                    }\n                    if (v === null || typeof v === 'undefined') {\n                        this.metadata.headers.delete(k);\n                    } else {\n                        this.metadata.headers.set(k, v);\n                    }\n                }\n            }\n        } else {\n            throw new Error('The \"dictionary\" argument must be null, a Map, or an object.');\n        }\n        return this;\n    }\n\n    /**\n     * Returns the metadata object to be utilized for stringifying into JSON.\n     * @returns {*}\n     * @protected\n     */\n    toJSON() {\n        let metaClone = { from: this.metadata.from };\n        if (this.metadata.headers) {\n            metaClone.headers = Object.fromEntries(this.metadata.headers);\n        }\n        if (this.metadata.count) {\n            metaClone.count = this.metadata.count;\n        }\n        if (this.metadata.skip) {\n            metaClone.skip = this.metadata.skip;\n        }\n        if (this.metadata.take) {\n            metaClone.take = this.metadata.take;\n        }\n        if (this.metadata.distinct) {\n            metaClone.distinct = this.metadata.distinct;\n        }\n        if (this.metadata.properties && this.metadata.properties.length) {\n            metaClone.properties = this.metadata.properties;\n        }\n        if (this.metadata.sorts && this.metadata.sorts.length) {\n            metaClone.sorts = this.metadata.sorts;\n        }\n        if (this.metadata.where && _filter_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"].isEmpty(this.metadata.where) === false) {\n            metaClone.where = JSON.stringify(this.metadata.where.toJSON());\n        }\n        return metaClone;\n    }\n\n}\n\nconst STANDARD_METADATA = ['properties', 'where', 'sorts', 'from', 'skip', 'take', 'distinct', 'count', 'model', 'headers'];\n\n/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (GetRequest);\n\n//# sourceURL=webpack://StashKu/./requests/get-request.js?");

/***/ }),

/***/ "./requests/options-request.js":
/*!*************************************!*\
  !*** ./requests/options-request.js ***!
  \*************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (__WEBPACK_DEFAULT_EXPORT__)\n/* harmony export */ });\n/* harmony import */ var _filter_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../filter.js */ \"./filter.js\");\n/* harmony import */ var _modeling_model_utility_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../modeling/model-utility.js */ \"./modeling/model-utility.js\");\n\n\n\n/**\n * This class defines a StashKu OPTIONS request that instructs StashKu to gather the schema for models from a \n * particular resource, and return a usable model (constructor) type.\n */\nclass OptionsRequest {\n    /**\n     * Creates a new `OptionsRequest` instance. A OPTIONS request that instructs StashKu to gather the schema for\n     * models from a particular resource.\n     * @param {String} [from] - The target resource name for the OPTIONS request.\n     */\n    constructor(from) {\n\n        this.metadata = {\n            /** @type {String} */\n            from: from || null,\n            /** @type {Map.<String, *>} */\n            headers: null\n        };\n    }\n\n    /**\n     * @type {String}\n     */\n    get method() {\n        return 'options';\n    }\n\n    /**\n     * Applies a StahKu-compatible model's metadata & configuration *not already defined* to this request.\n     * \n     * If a `null` value is passed, the model is removed - but metadata on the request will remain.\n     * @throws Error when the `modelType` argument is not `null`, a class, or a constructor object.\n     * @param {Modeling.AnyModelType} modelType - The model \"class\" or constructor function.\n     * @param {Boolean} [overwrite = false] - Optional flag that, when `true`, overwrites request settings and values\n     * with the model's (where applicable).\n     * @param {String} [resourceProp=\"resource\"] - The resource property used from the model type to set the resource on\n     * this request.\n     * @returns {OptionsRequest}\n     * @private\n     */\n    model(modelType, overwrite = false, resourceProp = 'resource') {\n        if (modelType !== null && _modeling_model_utility_js__WEBPACK_IMPORTED_MODULE_1__[\"default\"].isValidType(modelType) === false) {\n            throw new Error('Invalid \"modelType\" argument. The value must be null, a class, or a constructor object');\n        }\n        if (modelType) {\n            if (overwrite === true || !this.metadata.from) {\n                this.from(_modeling_model_utility_js__WEBPACK_IMPORTED_MODULE_1__[\"default\"].resource(modelType, this.method, resourceProp));\n            }\n        }\n        return this;\n    }\n\n    /**\n     * Sets the target resource name for the request, optionally specifying an alias for use with specifying properties\n     * across joins.\n     * \n     * @throws Error if the \"name\" argument value is not a string or null.\n     * @param {String} name - The name of the target resource in data storage. In an OPTIONS request you may also \n     * specify a `*` value to retrieve all model types.\n     * @returns {OptionsRequest}\n     */\n    from(name) {\n        if (name !== null && typeof name !== 'string') {\n            throw new Error('Invalid \"name\" argument. The value must be a string or null.');\n        }\n        this.metadata.from = name;\n        return this;\n    }\n\n    /**\n     * Sets the request resource 'from' value to a \"*\" which instructs storage engines to retrieve all available\n     * model types instead of a specific resource.\n     */\n    all() {\n        this.metadata.from = '*';\n    }\n\n    /**\n     * Clears all configured metadata on the request, resetting it to a default state.\n     * @returns {OptionsRequest}\n     */\n    clear() {\n        if (!this.metadata) {\n            this.metadata = {};\n        }\n        this.metadata.from = null;\n        this.metadata.headers = null;\n        return this;\n    }\n\n    /**\n     * Sets or clears headers on the request that can be used to set engine-specific options for the request.\n     * If a `null` value is passed, the headers are cleared.\n     * @throws Error when the dictionary argument uses a non-string key.\n     * @throws Error when the dictionary argument is not an object, null, or a Map.\n     * @param {Object | Map.<String, *>} dictionary - A map or object defining the headers and values.\n     * @returns {OptionsRequest}\n     */\n    headers(dictionary) {\n        if (!this.metadata.headers) {\n            this.metadata.headers = new Map();\n        }\n        if (dictionary === null) {\n            this.metadata.headers.clear();\n        } else if (dictionary instanceof Map || typeof dictionary === 'object') {\n            let iterable = dictionary;\n            if ((dictionary instanceof Map) === false) {\n                iterable = Object.entries(dictionary);\n            }\n            for (let [k, v] of iterable) {\n                if (k !== null && typeof k !== 'undefined') {\n                    if (typeof k !== 'string') {\n                        throw new Error('An invalid non-string key value was provided in the \"dictionary\" argument. Only string-based keys may be used.');\n                    }\n                    if (v === null || typeof v === 'undefined') {\n                        this.metadata.headers.delete(k);\n                    } else {\n                        this.metadata.headers.set(k, v);\n                    }\n                }\n            }\n        } else {\n            throw new Error('The \"dictionary\" argument must be null, a Map, or an object.');\n        }\n        return this;\n    }\n\n    /**\n     * Returns the metadata object to be utilized for stringifying into JSON.\n     * @returns {*}\n     * @protected\n     */\n    toJSON() {\n        let metaClone = { from: this.metadata.from };\n        if (this.metadata.headers) {\n            metaClone.headers = Object.fromEntries(this.metadata.headers);\n        }\n        return metaClone;\n    }\n\n}\n\n/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (OptionsRequest);\n\n//# sourceURL=webpack://StashKu/./requests/options-request.js?");

/***/ }),

/***/ "./requests/patch-request.js":
/*!***********************************!*\
  !*** ./requests/patch-request.js ***!
  \***********************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (__WEBPACK_DEFAULT_EXPORT__)\n/* harmony export */ });\n/* harmony import */ var _filter_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../filter.js */ \"./filter.js\");\n/* harmony import */ var _modeling_model_utility_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../modeling/model-utility.js */ \"./modeling/model-utility.js\");\n///<reference path=\"../modeling/modeling.d.js\" />\n\n\n\n/**\n * This class defines a StashKu PATCH request that instructs StashKu to update objects from storage with the specified\n * properties and values.\n */\nclass PatchRequest {\n    /**\n     * Creates a new `PatchRequest` instance. A PATCH request instructs StashKu to update objects from storage with \n     * the specified properties and values.\n     * @param  {*} [template] - A template object with properties and values to update in matching objects.\n     */\n    constructor(template) {\n\n        this.metadata = {\n            /** @type {Boolean} */\n            all: false,\n            /** @type {*} */\n            template: null,\n            /** @type {Filter} */\n            where: null,\n            /** @type {String} */\n            to: null,\n            /** @type {Boolean} */\n            count: false,\n            /** @type {Map.<String, *>} */\n            headers: null\n        };\n\n        if (template) {\n            this.template(template);\n        }\n    }\n\n    /**\n     * @type {String}\n     */\n    get method() {\n        return 'patch';\n    }\n\n    /**\n     * Applies a StahKu-compatible model's metadata & configuration *not already defined* to this request.\n     * \n     * If a `null` value is passed, the model is removed - but metadata on the request will remain.\n     * @throws Error when the `modelType` argument is not `null`, a class, or a constructor object.\n     * @param {Modeling.AnyModelType} modelType - The model \"class\" or constructor function.\n     * @param {Boolean} [overwrite = false] - Optional flag that, when `true`, overwrites request settings and values\n     * with the model's (where applicable).\n     * @param {String} [resourceProp=\"resource\"] - The resource property used from the model type to set the resource on\n     * this request.\n     * @returns {PatchRequest}\n     * @private\n     */\n    model(modelType, overwrite = false, resourceProp = 'resource') {\n        if (modelType !== null && _modeling_model_utility_js__WEBPACK_IMPORTED_MODULE_1__[\"default\"].isValidType(modelType) === false) {\n            throw new Error('Invalid \"modelType\" argument. The value must be null, a class, or a constructor object');\n        }\n        if (modelType) {\n            if (overwrite === true || !this.metadata.to) {\n                this.to(_modeling_model_utility_js__WEBPACK_IMPORTED_MODULE_1__[\"default\"].resource(modelType, this.method, resourceProp));\n            }\n            if (this.metadata.template) {\n                for (let m of _modeling_model_utility_js__WEBPACK_IMPORTED_MODULE_1__[\"default\"].unmodel(modelType, this.method, this.metadata.template)) {\n                    this.metadata.template = m;\n                }\n            }\n        }\n        return this;\n    }\n\n    /**\n     * Requests that the response return count numbers (total, affected, returned, etc.) but not objects.\n     * \n     * This will result in a `Response` with an empty `data` array and may result in faster query execution if you\n     * only need the resulting numbers.\n     * \n     * Calling this function without an argument *enables* counting without data.\n     * @param {Boolean} [enabled=true] - A `true` enables the count-only result. A `false` disables it.\n     * @returns {PatchRequest}\n     */\n    count(enabled) {\n        if (typeof enabled === 'undefined') {\n            this.metadata.count = true;\n        } else {\n            this.metadata.count = !!enabled;\n        }\n        return this;\n    }\n\n    /**\n     * Enables the update of all objects in data storage if no `where` conditions are specified. If conditions are\n     * specified, this setting will be ignored.\n     * \n     * Calling this method without an argument will set the request to *enable* the deletion of all objects.\n     * @param {Boolean} [enabled=true] - Enable or disable the deletion of all records when no `where` filters have\n     * been defined.\n     * @returns {PatchRequest}\n     */\n    all(enabled) {\n        if (arguments.length === 0) {\n            enabled = true;\n        }\n        this.metadata.all = !!enabled;\n        return this;\n    }\n\n    /**\n     * Sets a template object with properties and values to update in objects matched by this PATCH request.\n     * If a `null` value is passed, the template is removed and no updates will occur.\n     * @param  {*} [template] - A template object with properties and values to update.\n     * @returns {PatchRequest}\n     */\n    template(template) {\n        let ttype = typeof template;\n        if (ttype !== 'object' || Array.isArray(template)) {\n            throw new Error('Invalid \"template\" argument. The template value must be null or an object.');\n        }\n        if (!template) {\n            this.metadata.template = null;\n        } else {\n            this.metadata.template = template;\n        }\n        return this;\n    }\n\n    /**\n     * @callback ConditionCallback\n     * @param {Filter} f\n     */\n\n    /**\n     * Creates a set of conditions on the request to match specific objects in storage.    \n     * Any existing where conditions will be overwritten.    \n     * If a `null` value is passed, the where conditions are cleared.\n     * @throws Error if the \"conditions\" argument must be null or a Filter instance.\n     * @param {Filter|ConditionCallback} conditions - The conditions to be used to filter out results.\n     * @returns {PatchRequest}\n     */\n    where(conditions) {\n        if (conditions === null) {\n            this.metadata.where = null;\n            return this;\n        } else if (conditions instanceof _filter_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"]) {\n            this.metadata.where = conditions;\n        } else if (typeof conditions === 'string') {\n            this.metadata.where = _filter_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"].parse(conditions);\n        } else if (typeof conditions === 'function') {\n            this.metadata.where = new _filter_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"]();\n            conditions(this.metadata.where);\n        } else {\n            throw new Error('The \"conditions\" argument must be null, a callback, or a Filter instance.');\n        }\n        return this;\n    }\n\n    /**\n     * Sets the target resource name for the request, optionally specifying an alias for use with specifying properties\n     * across joins.\n     * \n     * @throws Error if the \"name\" argument value is not a string or null.\n     * @param {String} name - The name of the target resource in data storage.\n     * @returns {PatchRequest}\n     */\n    to(name) {\n        if (name !== null && typeof name !== 'string') {\n            throw new Error('Invalid \"name\" argument. The value must be a string or null.');\n        }\n        this.metadata.to = name;\n        return this;\n    }\n\n    /**\n     * Clears all configured metadata on the request, resetting it to a default state.\n     * @returns {PatchRequest}\n     */\n    clear() {\n        if (!this.metadata) {\n            this.metadata = {};\n        }\n        this.metadata.template = null;\n        this.metadata.where = null;\n        this.metadata.to = null;\n        this.metadata.headers = null;\n        return this;\n    }\n\n    /**\n     * Sets or clears headers on the request that can be used to set engine-specific options for the request.\n     * If a `null` value is passed, the headers are cleared.\n     * @throws Error when the dictionary argument uses a non-string key.\n     * @throws Error when the dictionary argument is not an object, null, or a Map.\n     * @param {Object | Map.<String, *>} dictionary - A map or object defining the headers and values.\n     * @returns {PatchRequest}\n     */\n    headers(dictionary) {\n        if (!this.metadata.headers) {\n            this.metadata.headers = new Map();\n        }\n        if (dictionary === null) {\n            this.metadata.headers.clear();\n        } else if (dictionary instanceof Map || typeof dictionary === 'object') {\n            let iterable = dictionary;\n            if ((dictionary instanceof Map) === false) {\n                iterable = Object.entries(dictionary);\n            }\n            for (let [k, v] of iterable) {\n                if (k !== null && typeof k !== 'undefined') {\n                    if (typeof k !== 'string') {\n                        throw new Error('An invalid non-string key value was provided in the \"dictionary\" argument. Only string-based keys may be used.');\n                    }\n                    if (v === null || typeof v === 'undefined') {\n                        this.metadata.headers.delete(k);\n                    } else {\n                        this.metadata.headers.set(k, v);\n                    }\n                }\n            }\n        } else {\n            throw new Error('The \"dictionary\" argument must be null, a Map, or an object.');\n        }\n        return this;\n    }\n\n    /**\n     * Returns the metadata object to be utilized for stringifying into JSON.\n     * @returns {*}\n     * @protected\n     */\n    toJSON() {\n        let metaClone = { to: this.metadata.to };\n        if (this.metadata.headers) {\n            metaClone.headers = Object.fromEntries(this.metadata.headers);\n        }\n        if (this.metadata.template) {\n            metaClone.template = this.metadata.template;\n        }\n        if (this.metadata.all) {\n            metaClone.all = this.metadata.all;\n        }\n        if (this.metadata.count) {\n            metaClone.count = this.metadata.count;\n        }\n        if (this.metadata.where && _filter_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"].isEmpty(this.metadata.where) === false) {\n            metaClone.where = this.metadata.where.toJSON();\n        }\n        return metaClone;\n    }\n\n}\n\nconst STANDARD_METADATA = ['all', 'template', 'where', 'to', 'count', 'headers'];\n\n/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (PatchRequest);\n\n//# sourceURL=webpack://StashKu/./requests/patch-request.js?");

/***/ }),

/***/ "./requests/post-request.js":
/*!**********************************!*\
  !*** ./requests/post-request.js ***!
  \**********************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (__WEBPACK_DEFAULT_EXPORT__)\n/* harmony export */ });\n/* harmony import */ var _modeling_model_utility_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../modeling/model-utility.js */ \"./modeling/model-utility.js\");\n\n\n/**\n * This class defines a StashKu POST request that instructs StashKu to create a new object in storage.\n */\nclass PostRequest {\n    /**\n     * Creates a new `PostRequest` instance. A POST request instructs StashKu to create a new object in storage.\n     * @param  {...String} [objects] - Spread of objects to create in data storage.\n     */\n    constructor(...objects) {\n\n        this.metadata = {\n            /** @type {Array} */\n            objects: [],\n            /** @type {String} */\n            to: null,\n            /** @type {Boolean} */\n            count: false,\n            /** @type {Map.<String, *>} */\n            headers: null\n        };\n\n        this.objects(...objects);\n    }\n\n    /**\n     * @type {String}\n     */\n    get method() {\n        return 'post';\n    }\n\n    /**\n     * Applies a StahKu-compatible model's metadata & configuration *not already defined* to this request.\n     * \n     * If a `null` value is passed, the model is removed - but metadata on the request will remain.\n     * @throws Error when the `modelType` argument is not `null`, a class, or a constructor object.\n     * @param {Modeling.AnyModelType} modelType - The model \"class\" or constructor function.\n     * @param {Boolean} [overwrite = false] - Optional flag that, when `true`, overwrites request settings and values\n     * with the model's (where applicable).\n     * @param {String} [resourceProp=\"resource\"] - The resource property used from the model type to set the resource on\n     * this request.\n     * @returns {PostRequest}\n     * @private\n     */\n    model(modelType, overwrite = false, resourceProp = 'resource') {\n        if (modelType !== null && _modeling_model_utility_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"].isValidType(modelType) === false) {\n            throw new Error('Invalid \"modelType\" argument. The value must be null, a class, or a constructor object');\n        }\n        if (modelType) {\n            if (overwrite === true || !this.metadata.to) {\n                this.to(_modeling_model_utility_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"].resource(modelType, this.method, resourceProp));\n            }\n            if (this.metadata.objects) {\n                this.metadata.objects = Array.from(_modeling_model_utility_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"].unmodel(modelType, this.method, ...this.metadata.objects));\n            }\n        }\n        return this;\n    }\n\n    /**\n     * Requests that the response return count numbers (total, affected, returned, etc.) but not objects.\n     * \n     * This will result in a `Response` with an empty `data` array and may result in faster query execution if you\n     * only need the resulting numbers.\n     * \n     * Calling this function without an argument *enables* the flag.\n     * @param {Boolean} [enabled=true] - A `true` enables the count-only result. A `false` disables it.\n     * @returns {PostRequest}\n     */\n    count(enabled) {\n        if (typeof enabled === 'undefined') {\n            this.metadata.count = true;\n        } else {\n            this.metadata.count = !!enabled;\n        }\n        return this;\n    }\n\n    /**\n     * Adds objects to the POST request. If any object has already been added to the request, it is skipped.    \n     * If a single `null` value is passed, all objects are cleared from the request.\n     * @param  {...any} [objects] - Spread of objects to create in data storage.\n     * @returns {PostRequest}\n     */\n    objects(...objects) {\n        if (Array.isArray(this.metadata.objects) === false) {\n            this.metadata.objects = [];\n        }\n        if (!objects || (objects.length === 1 && objects[0] === null)) {\n            this.metadata.objects.length = 0;\n        } else {\n            objects = objects.flat(Infinity);\n            for (let o of objects) {\n                let ttype = typeof o;\n                if (o !== null && ttype !== 'undefined') {\n                    if (ttype !== 'object') {\n                        throw new Error('Invalid \"objects\" argument. Values must be an object.');\n                    } else {\n                        this.metadata.objects.push(o);\n                    }\n                }\n            }\n        }\n        return this;\n    }\n\n    /**\n     * Sets the target resource name for the request, optionally specifying an alias for use with specifying properties\n     * across joins.\n     * \n     * @throws Error if the \"name\" argument value is not a string or null.\n     * @param {String} name - The name of the target resource in data storage.\n     * @returns {PostRequest}\n     */\n    to(name) {\n        if (name !== null && typeof name !== 'string') {\n            throw new Error('Invalid \"name\" argument. The value must be a string or null.');\n        }\n        this.metadata.to = name;\n        return this;\n    }\n\n    /**\n     * Clears all configured metadata on the request, resetting it to a default state.\n     * @returns {PostRequest}\n     */\n    clear() {\n        if (!this.metadata) {\n            this.metadata = {};\n        }\n        this.metadata.objects = [];\n        this.metadata.to = null;\n        this.metadata.headers = null;\n        return this;\n    }\n\n    /**\n     * Sets or clears headers on the request that can be used to set engine-specific options for the request.\n     * If a `null` value is passed, the headers are cleared.\n     * @throws Error when the dictionary argument uses a non-string key.\n     * @throws Error when the dictionary argument is not an object, null, or a Map.\n     * @param {Object | Map.<String, *>} dictionary - A map or object defining the headers and values.\n     * @returns {PostRequest}\n     */\n    headers(dictionary) {\n        if (!this.metadata.headers) {\n            this.metadata.headers = new Map();\n        }\n        if (dictionary === null) {\n            this.metadata.headers.clear();\n        } else if (dictionary instanceof Map || typeof dictionary === 'object') {\n            let iterable = dictionary;\n            if ((dictionary instanceof Map) === false) {\n                iterable = Object.entries(dictionary);\n            }\n            for (let [k, v] of iterable) {\n                if (k !== null && typeof k !== 'undefined') {\n                    if (typeof k !== 'string') {\n                        throw new Error('An invalid non-string key value was provided in the \"dictionary\" argument. Only string-based keys may be used.');\n                    }\n                    if (v === null || typeof v === 'undefined') {\n                        this.metadata.headers.delete(k);\n                    } else {\n                        this.metadata.headers.set(k, v);\n                    }\n                }\n            }\n        } else {\n            throw new Error('The \"dictionary\" argument must be null, a Map, or an object.');\n        }\n        return this;\n    }\n\n    /**\n     * Returns the metadata object to be utilized for stringifying into JSON.\n     * @returns {*}\n     * @protected\n     */\n    toJSON() {\n        let metaClone = { to: this.metadata.to };\n        if (this.metadata.headers) {\n            metaClone.headers = Object.fromEntries(this.metadata.headers);\n        }\n        if (this.metadata.count) {\n            metaClone.count = this.metadata.count;\n        }\n        if (this.metadata.objects && this.metadata.objects.length) {\n            metaClone.objects = this.metadata.objects;\n        }\n        return metaClone;\n    }\n\n}\n\nconst STANDARD_METADATA = ['objects', 'to', 'count', 'model', 'headers'];\n\n/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (PostRequest);\n\n//# sourceURL=webpack://StashKu/./requests/post-request.js?");

/***/ }),

/***/ "./requests/put-request.js":
/*!*********************************!*\
  !*** ./requests/put-request.js ***!
  \*********************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (__WEBPACK_DEFAULT_EXPORT__)\n/* harmony export */ });\n/* harmony import */ var _modeling_model_utility_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../modeling/model-utility.js */ \"./modeling/model-utility.js\");\n///<reference path=\"../modeling/modeling.d.js\" />\n\n\n/**\n * This class defines a StashKu PUT request that instructs StashKu to update existing objects in storage.\n */\nclass PutRequest {\n    /**\n     * Creates a new `PutRequest` instance. A PUT request instructs StashKu to update existing objects in storage.\n     * @param {Array.<String>} [pk] - The property name(s) that are used to uniquely identify each object.\n     * @param  {...String} [objects] - Spread of objects to create in update in storage.\n     */\n    constructor(pk, ...objects) {\n\n        this.metadata = {\n            /** @type {Array.<String>} */\n            pk: [],\n            /** @type {Array} */\n            objects: [],\n            /** @type {String} */\n            to: null,\n            /** @type {Boolean} */\n            count: false,\n            /** @type {Map.<String, *>} */\n            headers: null\n        };\n\n        if (Array.isArray(pk)) {\n            this.pk(...pk);\n        }\n        this.objects(...objects);\n    }\n\n    /**\n     * @type {String}\n     */\n    get method() {\n        return 'put';\n    }\n\n    /**\n     * Applies a StahKu-compatible model's metadata & configuration *not already defined* to this request.\n     * \n     * If a `null` value is passed, the model is removed - but metadata on the request will remain.\n     * @throws Error when the `modelType` argument is not `null`, a class, or a constructor object.\n     * @param {Modeling.AnyModelType} modelType - The model \"class\" or constructor function.\n     * @param {Boolean} [overwrite = false] - Optional flag that, when `true`, overwrites request settings and values\n     * with the model's (where applicable).\n     * @param {String} [resourceProp=\"resource\"] - The resource property used from the model type to set the resource on\n     * this request.\n     * @returns {PutRequest}\n     * @private\n     */\n    model(modelType, overwrite = false, resourceProp = 'resource') {\n        if (modelType !== null && _modeling_model_utility_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"].isValidType(modelType) === false) {\n            throw new Error('Invalid \"modelType\" argument. The value must be null, a class, or a constructor object');\n        }\n        if (modelType) {\n            if (overwrite === true || !this.metadata.to) {\n                this.to(_modeling_model_utility_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"].resource(modelType, this.method, resourceProp));\n            }\n            if (overwrite === true || !this.metadata.pk || !this.metadata.pk?.length) {\n                this\n                    .pk(null)\n                    .pk(..._modeling_model_utility_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"].pk(modelType));\n            }\n            if (this.metadata.objects) {\n                this.metadata.objects = Array.from(_modeling_model_utility_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"].unmodel(modelType, this.method, ...this.metadata.objects));\n            }\n        }\n        return this;\n    }\n\n    /**\n     * Requests that the response return count numbers (total, affected, returned, etc.) but not objects.\n     * \n     * This will result in a `Response` with an empty `data` array and may result in faster query execution if you\n     * only need the resulting numbers.\n     * \n     * Calling this function without an argument *enables* the flag.\n     * @param {Boolean} [enabled=true] - A `true` enables the count-only result. A `false` disables it.\n     * @returns {PutRequest}\n     */\n    count(enabled) {\n        if (typeof enabled === 'undefined') {\n            this.metadata.count = true;\n        } else {\n            this.metadata.count = !!enabled;\n        }\n        return this;\n    }\n\n    /**\n     * Defines the primary key property name(s) used to uniquely identify each object defined in the request and storage\n     * resource.    \n     * If a `null` value is passed, all PKs are cleared from the request.\n     * @param  {...String|Array.<String | Modeling.PropertyDefinition>} primaryKeys - Spread of property names used to uniquely identify each object.\n     * @returns {PutRequest}\n     */\n    pk(...primaryKeys) {\n        if (Array.isArray(this.metadata.pk) === false) {\n            this.metadata.pk = [];\n        }\n        if (!primaryKeys || (primaryKeys.length === 1 && primaryKeys[0] === null)) {\n            this.metadata.pk = [];\n        } else {\n            primaryKeys = primaryKeys.flat();\n            for (let k of primaryKeys) {\n                let prop = k;\n                if (k.target && typeof k.target === 'string') {\n                    prop = k.target;\n                }\n                if (typeof prop !== 'string') {\n                    throw new Error('Invalid \"primaryKeys\" argument. The array contains a non-string value.');\n                }\n                if (prop && this.metadata.pk.indexOf(prop) < 0) {\n                    this.metadata.pk.push(prop);\n                }\n            }\n        }\n        return this;\n    }\n\n    /**\n     * Adds objects to the PUT request. If any object has already been added to the request, it is skipped.    \n     * If a single `null` value is passed, all objects are cleared from the request.\n     * @param  {...any} [objects] - Spread of objects to update in data storage, as matched by `pk` property\n     * values.\n     * @returns {PutRequest}\n     */\n    objects(...objects) {\n        if (Array.isArray(this.metadata.objects) === false) {\n            this.metadata.objects = [];\n        }\n        if (!objects || (objects.length === 1 && objects[0] === null)) {\n            this.metadata.objects.length = 0;\n        } else {\n            objects = objects.flat(Infinity);\n            for (let o of objects) {\n                let ttype = typeof o;\n                if (o !== null && ttype !== 'undefined') {\n                    if (ttype !== 'object') {\n                        throw new Error('Invalid \"objects\" argument. Values must be an object.');\n                    } else if (this.metadata.objects.indexOf(o) < 0) {\n                        this.metadata.objects.push(o);\n                    }\n                }\n            }\n        }\n        return this;\n    }\n\n    /**\n     * Sets the target resource name for the request, optionally specifying an alias for use with specifying properties\n     * across joins.\n     * \n     * @throws Error if the \"name\" argument value is not a string or null.\n     * @param {String} name - The name of the target resource in data storage.\n     * @returns {PutRequest}\n     */\n    to(name) {\n        if (name !== null && typeof name !== 'string') {\n            throw new Error('Invalid \"name\" argument. The value must be a string or null.');\n        }\n        this.metadata.to = name;\n        return this;\n    }\n\n    /**\n     * Clears all configured metadata on the request, resetting it to a default state.\n     * @returns {PutRequest}\n     */\n    clear() {\n        if (!this.metadata) {\n            this.metadata = {};\n        }\n        this.metadata.pk = [];\n        this.metadata.objects = [];\n        this.metadata.to = null;\n        this.metadata.headers = null;\n        return this;\n    }\n\n    /**\n     * Sets or clears headers on the request that can be used to set engine-specific options for the request.\n     * If a `null` value is passed, the headers are cleared.\n     * @throws Error when the dictionary argument uses a non-string key.\n     * @throws Error when the dictionary argument is not an object, null, or a Map.\n     * @param {Object | Map.<String, *>} dictionary - A map or object defining the headers and values.\n     * @returns {PutRequest}\n     */\n    headers(dictionary) {\n        if (!this.metadata.headers) {\n            this.metadata.headers = new Map();\n        }\n        if (dictionary === null) {\n            this.metadata.headers.clear();\n        } else if (dictionary instanceof Map || typeof dictionary === 'object') {\n            let iterable = dictionary;\n            if ((dictionary instanceof Map) === false) {\n                iterable = Object.entries(dictionary);\n            }\n            for (let [k, v] of iterable) {\n                if (k !== null && typeof k !== 'undefined') {\n                    if (typeof k !== 'string') {\n                        throw new Error('An invalid non-string key value was provided in the \"dictionary\" argument. Only string-based keys may be used.');\n                    }\n                    if (v === null || typeof v === 'undefined') {\n                        this.metadata.headers.delete(k);\n                    } else {\n                        this.metadata.headers.set(k, v);\n                    }\n                }\n            }\n        } else {\n            throw new Error('The \"dictionary\" argument must be null, a Map, or an object.');\n        }\n        return this;\n    }\n\n    /**\n     * Returns the metadata object to be utilized for stringifying into JSON.\n     * @returns {*}\n     * @protected\n     */\n    toJSON() {\n        let metaClone = { to: this.metadata.to };\n        if (this.metadata.headers) {\n            metaClone.headers = Object.fromEntries(this.metadata.headers);\n        }\n        if (this.metadata.count) {\n            metaClone.count = this.metadata.count;\n        }\n        if (this.metadata.objects && this.metadata.objects.length) {\n            metaClone.objects = this.metadata.objects;\n        }\n        if (this.metadata.pk && this.metadata.pk.length) {\n            metaClone.pk = this.metadata.pk;\n        }\n        return metaClone;\n    }\n\n}\n\nconst STANDARD_METADATA = ['pk', 'objects', 'to', 'count', 'model', 'headers'];\n\n/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (PutRequest);\n\n//# sourceURL=webpack://StashKu/./requests/put-request.js?");

/***/ }),

/***/ "./response.js":
/*!*********************!*\
  !*** ./response.js ***!
  \*********************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (__WEBPACK_DEFAULT_EXPORT__)\n/* harmony export */ });\n/**\n * A standard response from a StashKu storage engine that completes a request.\n * @template M\n */\nclass Response {\n\n    /**\n     * Creates a standard response of the data returned by a StashKu storage engine.\n     * @param {Array.<M>} data - The data to be returned to the requesting caller.\n     * @param {Number} [total=0] - The total number of objects available to the request. If not specified the count of data objects is used.\n     * @param {Number} [affected=0] - The number of objects affected in storage.\n     * @param {Number} [returned=0] - The number of objects returned from storage.\n     * @param {Number} [code=200] - Optional status code to include as part of the response. If you are returning an\n     * error, consider throwing a `RestError` instead.\n     */\n    constructor(data, total, affected, returned, code) {\n\n        /**\n         * @type {Number}\n         */\n        this.code = code || 200;\n\n        /**\n         * An array of the objects returned from storage.\n         * @type {Array.<M>}\n         */\n        this.data = data || [];\n\n        /**\n         * The number of objects (records) *available* (i.e. resulting from) the request query in consideration of\n         * any `where` conditions, but disregarding any `skip` and `take` paging limitations.    \n         * @type {Number}\n         */\n        this.total = parseInt(total) || 0;\n\n        /**\n         * The number of objects (records) affected (altered/touched/created) in storage as a result of the request.\n         * \n         * This number is always `0` for GET requests.\n         * @type {Number}\n         */\n        this.affected = parseInt(affected) || 0;\n\n        /**\n         * The number of objects (records) returned from storage as a result of the request.    \n         * \n         * This number *will be* populated on GET requests utilizing the `.count()` flag, even though no objects are returned in `data`.\n         * @type {Number}\n         */\n        this.returned = parseInt(returned) || 0;\n\n        if (!this.total && this.data && this.data.length) {\n            this.total = this.data.length;\n        }\n    }\n\n    /**\n     * Returns an empty response with no objects and a total of 0.\n     * @returns {Response}\n     */\n    static empty() {\n        return new Response();\n    }\n\n}\n\n/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (Response);\n\n//# sourceURL=webpack://StashKu/./response.js?");

/***/ }),

/***/ "./rest-error.js":
/*!***********************!*\
  !*** ./rest-error.js ***!
  \***********************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (__WEBPACK_DEFAULT_EXPORT__)\n/* harmony export */ });\nconst validErrorCodes = [100, 101, 102, 103, 200, 201, 202, 203, 204, 205, 206, 207, 208, 226, 300, 301, 302, 303, 304, 305, 307, 308, 400, 401, 402, 403, 404, 405, 406, 407, 408, 409, 410, 411, 412, 413, 414, 415, 416, 417, 418, 421, 422, 423, 424, 425, 426, 428, 429, 431, 451, 500, 501, 502, 503, 504, 505, 506, 507, 508, 509, 510, 511]\n\n/**\n * A RESTful error that can be used for actions processing requests and responses.\n */\nclass RESTError extends Error {\n    /**\n     * Creates a new RESTful error with a HTTP-compliant status code.\n     * @param {Number} [code] - A standard HTTP-compliant status code.\n     * @param {String} [message] - The error message.\n     * @param {Error} [innerError] - An inner error that was thrown.\n     */\n    constructor(code, message, innerError) {\n        super(message);\n        //soft validate\n        if (code < 400 || code >= 600 || validErrorCodes.indexOf(code) < 0) {\n            // eslint-disable-next-line no-console\n            console.warn(`Invalid RESTful response code \"${code}\". The code should be an HTTP-complient status code in the 4xx or 5xx block.`);\n        }\n\n        /**\n         * @type {Number}\n         */\n        this.code = code;\n\n        Error.captureStackTrace(this, RESTError);\n        if (innerError && innerError.stack) {\n            this.stack += `\\nEngine ${innerError.stack}`;\n        }\n    }\n}\n\n/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (RESTError);\n\n//# sourceURL=webpack://StashKu/./rest-error.js?");

/***/ }),

/***/ "./sort.js":
/*!*****************!*\
  !*** ./sort.js ***!
  \*****************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (__WEBPACK_DEFAULT_EXPORT__)\n/* harmony export */ });\n\nclass Sort {\n    constructor(property, dir) {\n\n        /**\n         * @type {String}\n         */\n        this.property = property || null;\n\n        /**\n         * @type {String}\n         */\n        this.dir = dir || Sort.DIR.ASC;\n    }\n\n    /**\n     * Returns a string representation of the sort property and direction. If the property is missing, then a blank\n     * string is returned.\n     * @returns {String}\n     */\n    toString() {\n        if (this.property && this.dir) {\n            return `{${this.property}} ${this.dir.toUpperCase()}`;\n        } else if (this.property) {\n            return `{${this.property}}`;\n        }\n        return '';\n    }\n\n    /**\n     * Creates a new `Sort` instance that indicates an ascending sort order for the given property.\n     * @param {String} property - The property to be sorted.\n     * @returns {Sort}\n     */\n    static asc(property) {\n        return new Sort(property, Sort.DIR.ASC);\n    }\n\n    /**\n     * Creates a new `Sort` instance that indicates an descending sort order for the given property.\n     * @param {String} property - The property to be sorted.\n     * @returns {Sort}\n     */\n    static desc(property) {\n        return new Sort(property, Sort.DIR.DESC);\n    }\n\n    /**\n     * Returns a new `Sort` instance (or array of `Sort` instances from a string representation. If no\n     * sorts are defined, a `null` is returned.\n     * @example\n     * let myOrderBy = Sort.parse('FirstName desc'); //returns a single Sort\n     * @example\n     * let mySorts = Sort.parse('FirstName, LastName desc'); //returns array of Sort\n     * @param {String} input - The string to deconstruct.\n     * @returns {Sort|Array.<Sort>} A single `Sort` instance when only one Sort is specifiedy, otherwise\n     * an array of `Sort` instances is returned (in order).\n     */\n    static parse(input) {\n        if (input && typeof input === 'string') {\n            let sorts = [];\n            let openSort = null;\n            let tokens = Sort._tokenize(input);\n            for (let i = 0; i < tokens.length; i++) {\n                let t = tokens[i];\n                if (!openSort && t.type === 'property') {\n                    openSort = new Sort(t.value);\n                } else if (openSort && t.type === 'order') {\n                    openSort.dir = t.value;\n                } else if (openSort && t.type === 'separator') {\n                    sorts.push(openSort);\n                    openSort = null;\n                }\n            }\n            if (openSort) {\n                sorts.push(openSort);\n            }\n            if (sorts.length === 1) {\n                return sorts[0];\n            } else if (sorts.length > 1) {\n                return sorts;\n            }\n        }\n        return null;\n    }\n\n    /**\n     * @typedef SortToken\n     * @property {String} type\n     * @property {String} value\n     */\n\n    /**\n     * Tokenizes a string containing 0 or more property sorts.\n     * @param {String} input - the input Sort string.\n     * @returns {Array.<SortToken>}\n     * @private\n     */\n    static _tokenize(input) {\n        let tokens = [];\n        let openToken = null;\n        for (let i = 0; i < input.length; i++) {\n            if (openToken?.type === 'property') {\n                if (input[i - 1] !== '\\\\' && input[i] === '}') {\n                    tokens.push(openToken);\n                    openToken = null;\n                } else {\n                    if (input[i - 1] === '\\\\' && input[i] === '}') {\n                        openToken.value = openToken.value.substr(0, openToken.value.length - 1) + '}';\n                    } else if (input[i - 1] === '\\\\' && input[i] === '{') {\n                        openToken.value = openToken.value.substr(0, openToken.value.length - 1) + '{';\n                    } else {\n                        openToken.value += input[i];\n                    }\n                }\n            } else if (/asc/i.test(input.substr(i, 3))) {\n                tokens.push({\n                    type: 'order',\n                    value: Sort.DIR.ASC\n                });\n                i += 2;\n            } else if (/desc/i.test(input.substr(i, 4))) {\n                tokens.push({\n                    type: 'order',\n                    value: Sort.DIR.DESC\n                });\n                i += 3;\n            } else if (input[i] === ',') {\n                tokens.push({\n                    type: 'separator'\n                });\n            } else if (input[i - 1] !== '\\\\' && input[i] === '{') {\n                openToken = {\n                    type: 'property',\n                    value: ''\n                };\n            } else if (/\\s/.test(input[i]) === false) {\n                throw new SyntaxError(`Failed to tokenize sort string, unknown value at position ${i} was found (are you surrounding property names with braces \"{...}\"?).`);\n            }\n        }\n        //validate\n\n        return tokens;\n    }\n}\n\nSort.DIR = {\n    ASC: 'asc',\n    DESC: 'desc'\n};\n\n/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (Sort);\n\n//# sourceURL=webpack://StashKu/./sort.js?");

/***/ }),

/***/ "./stashku.js":
/*!********************!*\
  !*** ./stashku.js ***!
  \********************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"BaseEngine\": () => (/* reexport safe */ _engines_base_engine_js__WEBPACK_IMPORTED_MODULE_14__[\"default\"]),\n/* harmony export */   \"DeleteRequest\": () => (/* reexport safe */ _requests_delete_request_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"]),\n/* harmony export */   \"Filter\": () => (/* reexport safe */ _filter_js__WEBPACK_IMPORTED_MODULE_8__[\"default\"]),\n/* harmony export */   \"GetRequest\": () => (/* reexport safe */ _requests_get_request_js__WEBPACK_IMPORTED_MODULE_1__[\"default\"]),\n/* harmony export */   \"ModelGenerator\": () => (/* reexport safe */ _modeling_model_generator_js__WEBPACK_IMPORTED_MODULE_11__[\"default\"]),\n/* harmony export */   \"ModelUtility\": () => (/* reexport safe */ _modeling_model_utility_js__WEBPACK_IMPORTED_MODULE_12__[\"default\"]),\n/* harmony export */   \"OptionsRequest\": () => (/* reexport safe */ _requests_options_request_js__WEBPACK_IMPORTED_MODULE_2__[\"default\"]),\n/* harmony export */   \"PatchRequest\": () => (/* reexport safe */ _requests_patch_request_js__WEBPACK_IMPORTED_MODULE_3__[\"default\"]),\n/* harmony export */   \"PostRequest\": () => (/* reexport safe */ _requests_post_request_js__WEBPACK_IMPORTED_MODULE_4__[\"default\"]),\n/* harmony export */   \"PutRequest\": () => (/* reexport safe */ _requests_put_request_js__WEBPACK_IMPORTED_MODULE_5__[\"default\"]),\n/* harmony export */   \"RESTError\": () => (/* reexport safe */ _rest_error_js__WEBPACK_IMPORTED_MODULE_7__[\"default\"]),\n/* harmony export */   \"Response\": () => (/* reexport safe */ _response_js__WEBPACK_IMPORTED_MODULE_6__[\"default\"]),\n/* harmony export */   \"Sort\": () => (/* reexport safe */ _sort_js__WEBPACK_IMPORTED_MODULE_10__[\"default\"]),\n/* harmony export */   \"StringUtility\": () => (/* reexport safe */ _utilities_string_utility_js__WEBPACK_IMPORTED_MODULE_13__[\"default\"]),\n/* harmony export */   \"default\": () => (/* binding */ StashKu)\n/* harmony export */ });\n/* harmony import */ var _requests_delete_request_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./requests/delete-request.js */ \"./requests/delete-request.js\");\n/* harmony import */ var _requests_get_request_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./requests/get-request.js */ \"./requests/get-request.js\");\n/* harmony import */ var _requests_options_request_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./requests/options-request.js */ \"./requests/options-request.js\");\n/* harmony import */ var _requests_patch_request_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./requests/patch-request.js */ \"./requests/patch-request.js\");\n/* harmony import */ var _requests_post_request_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./requests/post-request.js */ \"./requests/post-request.js\");\n/* harmony import */ var _requests_put_request_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./requests/put-request.js */ \"./requests/put-request.js\");\n/* harmony import */ var _response_js__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ./response.js */ \"./response.js\");\n/* harmony import */ var _rest_error_js__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ./rest-error.js */ \"./rest-error.js\");\n/* harmony import */ var _filter_js__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! ./filter.js */ \"./filter.js\");\n/* harmony import */ var _logger_js__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! ./logger.js */ \"./logger.js\");\n/* harmony import */ var _sort_js__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(/*! ./sort.js */ \"./sort.js\");\n/* harmony import */ var _modeling_model_generator_js__WEBPACK_IMPORTED_MODULE_11__ = __webpack_require__(/*! ./modeling/model-generator.js */ \"./modeling/model-generator.js\");\n/* harmony import */ var _modeling_model_utility_js__WEBPACK_IMPORTED_MODULE_12__ = __webpack_require__(/*! ./modeling/model-utility.js */ \"./modeling/model-utility.js\");\n/* harmony import */ var _utilities_string_utility_js__WEBPACK_IMPORTED_MODULE_13__ = __webpack_require__(/*! ./utilities/string-utility.js */ \"./utilities/string-utility.js\");\n/* harmony import */ var _engines_base_engine_js__WEBPACK_IMPORTED_MODULE_14__ = __webpack_require__(/*! ./engines/base-engine.js */ \"./engines/base-engine.js\");\n/* harmony import */ var _engines_memory_engine_js__WEBPACK_IMPORTED_MODULE_15__ = __webpack_require__(/*! ./engines/memory-engine.js */ \"./engines/memory-engine.js\");\n/* harmony import */ var _engines_fetch_engine_js__WEBPACK_IMPORTED_MODULE_16__ = __webpack_require__(/*! ./engines/fetch-engine.js */ \"./engines/fetch-engine.js\");\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nconst SUPPORTED_METHODS = ['all', '*', 'get', 'post', 'put', 'patch', 'delete', 'options'];\nconst SUPPORTED_STATES = ['log', 'request', 'response', 'done'];\nconst IS_BROWSER = (typeof window !== 'undefined');\nlet HttpRequestLoader = null; //see .requestFromObject\n\n/**\n * @callback StashKuMiddlewareCallback\n * @param {StashKu} stashku - The StashKu instance making the middleware call.\n * @param {BaseEngine} engine - The storage engine instance that is processing the request.\n * @param {String} method - The name of the request method being carried out, typically \"get\", \"post\", \"put\", \"patch\",\n * \"delete\", \"options\".\n * @param {GetRequest|PostRequest|PutRequest|PatchRequest|DeleteRequest|OptionsRequest} request - The request object being specified.\n * @param {Response} response - The response object (`null` if not prepared yet).\n * @param {String} state \n * The name of the state of where in the RESTful process the callback is being made, either:\n *  - \"request\": Indicates the callback was made before the request has handed off to the engine.\n *  - \"response\": Indicates the callback was made after the engine's response has been returned.\n *  - \"done\": Indicates the callback was made after the engine has completed the response and the action is about to\n * complete (StashKu hands off the storage engine response to the caller).\n */\n\n/**\n * @callback StashKuMiddlewareLogCallback\n * @param {StashKu} stashku - The StashKu instance making the middleware call.\n * @param {BaseEngine} engine - The storage engine instance that is currently loaded.\n * @param {String} severity - The severity level of the log message, either \"error\", \"warn\", \"info\", or \"debug\".\n * @param {Array} args - The log message arguments, this can be a mix of types.\n */\n\n/**\n * @typedef StashKuMiddleware\n * @property {String} [name] - An optional name for the middleware that is used for logging purposes.\n * @property {Array.<String>} [states] - The name(s) of the states to target, either \"all\"/\"*\", \"log\", \"request\", \n * \"response\", or \"done\".\n * @property {Array.<String>} [methods] - The name(s) of the methods to target, either \"all\"/\"*\", \"get\", \"post\", \"put\",\n * \"patch\" or \"delete\".\n * @property {StashKuMiddlewareCallback|StashKuMiddlewareLogCallback} callback - The callback to be called when being processed.\n */\n\n/**\n * @typedef StashKuModelConfiguration\n * @property {String} resource - Instructs StashKu which property from the `$stashku` object on a model type to\n * populate the resource (`to` or `from`) on a request. Can be `\"name\"`, `\"slug\"`, `\"plural.name\"`, `\"plural.slug\"`,\n * or `\"resource\"` (default).\n */\n\n/**\n * @typedef StashKuConfiguration\n * @property {String|BaseEngine} engine - The name or instance of the StashKu engine to use.\n * @property {Array.<StashKuMiddleware|StashKuMiddlewareCallback|StashKuMiddlewareLogCallback>} middleware\n * @property {StashKuModelConfiguration} model - Configuration describing how StashKu works with models.\n * @property {Array.<String>} resources - Optional array of resource names that are allowed through this instance of\n * StashKu. Any request asking for a resource not found in this array will throw an error.\n */\n\n/**\n * The StashKu class provides the ability to work with a variety of storage mediums through a single, standardized,\n * RESTful interface, working much like HTTP - using a request and a response.\n * \n * StashKu supports middleware which can be configured to pre- and post-process requests and responses.\n * @template M\n * @template I\n */\nclass StashKu {\n    /**\n     * Creates a new StashKu instance using the provided configuration settings (which override defaults).\n     * @param {StashKu | StashKuConfiguration} [config] - The configuration settings which override defaults.\n     */\n    constructor(config) {\n        /**\n         * The currently active storage engine, or the promise to load it.\n         * All operations will await the engine if it is a promise.\n         * @type {BaseEngine|Promise.<BaseEngine>}\n         */\n        this.engine = null;\n\n        /**\n         * Holds onto the last loaded configuration.    \n         * If you wish to change the configuration, you should use the `configure` function.\n         * @type {StashKuConfiguration}\n         */\n        this.config = null;\n\n        /**\n         * Middleware functions that execute before sending requests or returning responses.\n         * @type {Array.<StashKuMiddleware>}\n         */\n        this.middleware = [];\n\n        /**\n         * Counter of all requests handled by this instance (or parent instance in the case of a proxy) of stashku.\n         */\n        this.stats = {\n            requests: {\n                total: 0,\n                get: 0,\n                put: 0,\n                post: 0,\n                patch: 0,\n                delete: 0,\n                options: 0\n            }\n        };\n\n        /**\n         * @type {Logger}\n         */\n        this.log = null;\n\n        if (config && config.proxy && config.proxy.model && config.proxy.parent) {\n            //this instance is being crafted for a call to the `.model` function and is meant to act as\n            //a proxy to a parent StashKu class.\n            if ((config.proxy.parent instanceof StashKu) === false) {\n                throw new _rest_error_js__WEBPACK_IMPORTED_MODULE_7__[\"default\"](500, 'StashKu cannot initialize a proxy instance from a non-StashKu parent instance.');\n            }\n            this.log = config.proxy.parent.log;\n            this.engine = config.proxy.parent.engine;\n            this.middleware = config.proxy.parent.middleware;\n            this.stats = config.proxy.parent.stats;\n            this.resources = config.proxy.parent.resources;\n            //shallow-clone configuration, set proxy\n            this.config = Object.assign({}, config.proxy.parent.config, { proxy: config.proxy }, { model: config.proxy.parent.config.model });\n        } else {\n            this.log = new _logger_js__WEBPACK_IMPORTED_MODULE_9__[\"default\"](this.middlerun.bind(this));\n            //apply standard configuration\n            this.configure(config ?? null);\n        }\n    }\n\n    /**\n     * Adds the specified middleware to the StashKu instance.\n     * @param {StashKuMiddleware|StashKuMiddlewareCallback|StashKuMiddlewareLogCallback} middleware - The middleware to use.\n     * @returns {StashKu}\n     */\n    use(middleware) {\n        if (typeof middleware === 'function') {\n            //config specifies a single middleware function.\n            this.middleware.push({\n                callback: middleware\n            });\n            this.log.debug(`Unnamed middleware loaded at position ${this.middleware.length - 1}.`);\n        } else if (middleware.callback) {\n            if (middleware.states) {\n                if (typeof middleware.states === 'string') {\n                    middleware.states = [middleware.states]; //convert to array\n                } else if (Array.isArray(middleware.states) === false) {\n                    throw new _rest_error_js__WEBPACK_IMPORTED_MODULE_7__[\"default\"](500, 'The middleware specified contains invalid states. The states specified must be a string or array of strings.');\n                }\n                if (middleware.states.every(m => typeof m === 'string') === false) {\n                    throw new _rest_error_js__WEBPACK_IMPORTED_MODULE_7__[\"default\"](500, 'The middleware specified contains invalid states. All state values specified must be strings.');\n                } else if (middleware.states.every(m => SUPPORTED_STATES.indexOf(m) >= 0) === false) {\n                    throw new _rest_error_js__WEBPACK_IMPORTED_MODULE_7__[\"default\"](500, `The middleware specified contains invalid states. Only \"${SUPPORTED_STATES.join('\", \"')}\" states are allowed.`);\n                }\n            }\n            if (middleware.methods) {\n                if (typeof middleware.methods === 'string') {\n                    middleware.methods = [middleware.methods]; //convert to array\n                } else if (Array.isArray(middleware.methods) === false) {\n                    throw new _rest_error_js__WEBPACK_IMPORTED_MODULE_7__[\"default\"](500, 'The middleware specified contains invalid methods. The methods specified must be a string or array of strings.');\n                }\n                if (middleware.methods.every(m => typeof m === 'string') === false) {\n                    throw new _rest_error_js__WEBPACK_IMPORTED_MODULE_7__[\"default\"](500, 'The middleware specified contains invalid methods. All method values specified must be strings.');\n                } else if (middleware.methods.every(m => SUPPORTED_METHODS.indexOf(m) >= 0) === false) {\n                    throw new _rest_error_js__WEBPACK_IMPORTED_MODULE_7__[\"default\"](500, `The middleware specified contains invalid methods. Only \"${SUPPORTED_METHODS.join('\", \"')}\" methods are allowed.`);\n                }\n            }\n            this.middleware.push(middleware);\n            if (middleware.name) {\n                this.log.debug(`\"${middleware.name}\" middleware loaded at position ${this.middleware.length - 1}.`);\n            } else {\n                this.log.debug(`Unnamed middleware loaded at position ${this.middleware.length - 1}.`);\n            }\n        }\n        return this;\n    }\n\n    /**\n     * Configures this StashKu instance with the specified configuration. If a `null` value is passed, the\n     * configuration is cleared and reset to the default.\n     * \n     * When the `config` parameter is undefined (not specified), this function can be awaited. This will await the \n     * import and load of the configured StashKu engine. If the engine is already loaded, the function will return.\n     * @throws Error if the configured storage engine name (`config.engine`) is not registered with StashKu.\n     * @param {StashKuConfiguration} [config] - The configuration settings which override defaults.\n     * @returns {StashKu}\n     */\n    configure(config) {\n        if (typeof config === 'undefined') {\n            if (this.engine && this.engine.then) {\n                return this.engine.then((v) => this);\n            } else {\n                return this;\n            }\n        }\n        this.log.debug('Configuring StashKu...');\n        //assign defaults\n        let engineDefault = 'memory';\n        let modelDefault = {\n            resource: 'resource'\n        };\n        if (IS_BROWSER) {\n            engineDefault = 'fetch';\n        } else {\n            engineDefault = process.env.STASHKU_ENGINE ?? 'memory';\n            modelDefault.resource = process.env.STASHKU_MODEL_RESOURCE ?? 'resource';\n        }\n        this.config = Object.assign({\n            engine: engineDefault,\n            middleware: [],\n            resources: []\n        }, config, { model: Object.assign(modelDefault, config?.model) });\n        this.log.debug('Configuration=', this.config);\n        //validate config\n        if (this.config?.model?.resource && ['resource', 'name', 'slug', 'plural.name', 'plural.slug'].indexOf(this.config.model.resource) < 0) {\n            throw new Error('Invalid \"model.resource\" configuration value. The value must be \"resource\", \"name\", \"slug\", \"plural.name\", or \"plural.slug\".');\n        }\n        //load engine\n        if (this.config.engine === 'memory') {\n            this.engine = new _engines_memory_engine_js__WEBPACK_IMPORTED_MODULE_15__[\"default\"]();\n            this.engine.configure(this.config.memory, this.log);\n        } else if (this.config.engine === 'fetch') {\n            this.engine = new _engines_fetch_engine_js__WEBPACK_IMPORTED_MODULE_16__[\"default\"]();\n            this.engine.configure(this.config.fetch, this.log);\n        } else if (typeof this.config.engine === 'string' && IS_BROWSER === false) {\n            let enginePackageName = this.config.engine;\n            this.engine = import(/* webpackIgnore: true */'./node/package-loader.js')\n                .then((loader) => {\n                    return loader.default(enginePackageName)\n                        .then(m => {\n                            this.engine = new m.default();\n                            this.engine.configure(this.config[this.config.engine], this.log);\n                        });\n                });\n        } else if (this.config.engine instanceof _engines_base_engine_js__WEBPACK_IMPORTED_MODULE_14__[\"default\"]) {\n            this.engine = this.config.engine;\n        }\n        //load middleware\n        if (Array.isArray(this.config.middleware)) {\n            //array of possible middleware functions and objects\n            for (let mw of this.config.middleware) {\n                this.use(mw);\n            }\n        } else if (typeof this.config.middleware === 'function') {\n            //config specifies a single middleware function.\n            this.middleware.push({\n                callback: this.config.middleware\n            });\n        }\n        this.log.debug('Done configuring StashKu.');\n        return this;\n    }\n\n    /**\n     * Runs configured middleware callbacks matching the current state and request method.\n     * @param {String} state \n     * The name of the state of where in the RESTful process the callback is being made, either:\n     *  - \"request\": Indicates the callback was made before the request has handed off to the engine.\n     *  - \"response\": Indicates the callback was made before the engine's response has been considered.\n     *  - \"done\": Indicates the callback was made after the engine has completed the response and the action is about to\n     * complete (StashKu hands off the storage engine response to the caller).\n     * @param {GetRequest|PostRequest|PutRequest|PatchRequest|DeleteRequest|OptionsRequest} request - The request object being specified.\n     * @param {Promise.<Response>} response - The response object (`null` if not prepared yet).\n     */\n    async middlerun(state, request, response) {\n        if (SUPPORTED_STATES.indexOf(state) < 0) {\n            throw new Error(`The \"state\" argument specified contain an invalid value. Only \"${SUPPORTED_STATES.join('\", \"')}\" states are allowed.`);\n        }\n        if (this.middleware && this.middleware.length) {\n            for (let x = 0; x < this.middleware.length; x++) {\n                let mw = this.middleware[x];\n                if (mw.callback) {\n                    let stateAllowed = (!mw.states || mw.states.length === 0 || mw.states.indexOf(state) >= 0);\n                    let methodAllowed = (\n                        state === 'log'\n                        || !mw.methods\n                        || mw.methods.indexOf('*') >= 0\n                        || mw.methods.indexOf('all') >= 0\n                        || mw.methods.indexOf(request.method) >= 0\n                    );\n                    if (stateAllowed && methodAllowed) {\n                        if (state === 'log') {\n                            //under the \"log\" state...\n                            //request = severity string\n                            //response = args array\n                            await mw.callback(this, this.engine, request, response);\n                        } else {\n                            if (mw.name) {\n                                this.log.debug(`Calling middleware ${x + 1} of ${this.middleware.length} \"${mw.name}\".`);\n                            } else {\n                                this.log.debug(`Calling middleware ${x + 1} of ${this.middleware.length}.`);\n                            }\n                            await mw.callback(this, this.engine, request.method, request, response, state);\n                            this.log.debug(`Completed middleware call ${x + 1} of ${this.middleware.length}.`);\n                        }\n                    }\n                }\n            }\n        }\n    }\n\n    /**\n     * Handles the `request` and ensures it is resolved to a response object, even when defined as a callback.\n     * \n     * @throws Error if the \"request\" argument is not a callback function or request-like instance.\n     * @throws Error if the engine module fails to load.\n     * @throws Error if the engine is `null`.\n     * @param {GetRequest|PostRequest|PutRequest|PatchRequest|DeleteRequest|OptionsRequest} request - The request to ensure.\n     * @param {*} requestType - The expected request instance type.\n     * @returns {Promise.<Response>} Returns the data objects from storage matching request criteria.\n     * @private\n     */\n    async _handle(request, requestType) {\n        //validate arguments\n        if (!requestType) {\n            throw new Error('A \"requestType\" parameter argument is required.');\n        }\n        //handle http.IncomingMessageg\n        if (IS_BROWSER === false && request.url && request.httpVersion) {\n            request = await StashKu.requestFromObject(request);\n        }\n        //build request\n        let reqModel = this.config?.proxy?.model;\n        if (typeof request === 'function') {\n            //process callback\n            let tmp = new requestType();\n            if (reqModel) {\n                request(tmp, reqModel);\n                tmp.model(reqModel, false, this.config?.model?.resource);\n            } else {\n                request(tmp);\n            }\n            request = tmp;\n        } else if ((request instanceof requestType) === false) {\n            throw new Error(`The \"request\" argument must be a callback function or ${requestType.name} instance.`);\n        } else if (!this.engine) {\n            throw new Error('A StashKu storage engine has not been loaded. An engine must be configured before operations are allowed.');\n        } else if (reqModel) {\n            request.model(reqModel, false, this.config?.model?.resource);\n        }\n        //access restrictions\n        if (this.config.resources && this.config.resources.length) {\n            let resource = request.metadata.from || request.metadata.to;\n            if (this.config.resources.indexOf(resource) < 0) {\n                throw new _rest_error_js__WEBPACK_IMPORTED_MODULE_7__[\"default\"](403, 'Forbidden.');\n            }\n        }\n        //pre-process request\n        let response = null;\n        this.stats.requests[request.method]++;\n        this.stats.requests.total++;\n        let reqID = this.stats.requests.total.toString().padStart(16, '0');\n        this.log.debug(`[${reqID}] Processing \"${request.method}\" request.`);\n        try {\n            await this.engine; //resolve if a promise.\n        } catch (err) {\n            throw new _rest_error_js__WEBPACK_IMPORTED_MODULE_7__[\"default\"](500, `The StashKu storage engine \"${this.config.engine}\" could not be loaded. ${err.toString()}`);\n        }\n        this.log.debug(`[${reqID}] Running \"${request.method}\" request middleware.`);\n        await this.middlerun('request', request, response);\n        if (this.engine[request.method]) {\n            try {\n                //make the request and get the response\n                this.log.debug(`[${reqID}] Sending \"${request.method}\" request to engine \"${this.engine.name}\".`);\n                response = await this.engine[request.method](request);\n                this.log.debug(`[${reqID}] Received response for \"${request.method}\" request from engine \"${this.engine.name}\".`);\n                if (reqModel) {\n                    //convert data\n                    this.log.debug(`[${reqID}] Modelling response data.`);\n                    if (response.data && response.data.length) {\n                        let counter = 0;\n                        for (let m of _modeling_model_utility_js__WEBPACK_IMPORTED_MODULE_12__[\"default\"].model(reqModel, request.method, ...response.data)) {\n                            response.data[counter] = m;\n                            counter++;\n                        }\n                    }\n                }\n                this.log.debug(`[${reqID}] Running middleware for response.`);\n                await this.middlerun('response', request, response);\n            } catch (err) {\n                if ((err instanceof _rest_error_js__WEBPACK_IMPORTED_MODULE_7__[\"default\"]) === false) {\n                    throw new _rest_error_js__WEBPACK_IMPORTED_MODULE_7__[\"default\"](500, `A StashKu internal error occurred while using storage engine \"${this.engine.name}\".`, err);\n                }\n                throw err;\n            }\n        } else {\n            throw new _rest_error_js__WEBPACK_IMPORTED_MODULE_7__[\"default\"](501, `The StashKu storage engine \"${this.engine.name}\" does not know how to handle the method \"${request.method}\".`);\n        }\n        //validate engine response\n        if (!response) {\n            throw new _rest_error_js__WEBPACK_IMPORTED_MODULE_7__[\"default\"](403, `The StashKu storage engine \"${this.engine.name}\" did not return a response.`);\n        } else if ((response instanceof _response_js__WEBPACK_IMPORTED_MODULE_6__[\"default\"]) === false) {\n            throw new _rest_error_js__WEBPACK_IMPORTED_MODULE_7__[\"default\"](500, `The StashKu storage engine \"${this.engine.name}\" returned an invalid response.`);\n        }\n        this.log.debug(`[${reqID}] Returning \"${request.method}\" response with total value of ${response ? response.total : '(null)'}.`);\n        return response;\n    }\n\n    /**\n     * This method safely cleans up resources and should be called after the use of the StashKu instance is complete,\n     * such as just before application exit.\n     */\n    async destroy() {\n        if (this.engine && this.engine.destroy) {\n            await this.engine.destroy();\n        }\n    }\n\n    /**\n     * @template T\n     * @typedef {new(...args: Array) | new(...args: Array) => T} Constructor\n     **/\n\n    /**\n     * Attaches a model to StashKu operations through a new returned (proxy) StashKu instance. The model is attached\n     * only to the returned proxying instance. This allows the use of the model within the request callback methods\n     * as the second argument (`model`), and the resulting `Response` data to be instances of the model.\n     * \n     * @example\n     * let sk = new StashKu();\n     * ...\n     * //the model object will be exposed as the \"m\" argument in the callback.\n     * await sk.model(PersonModel).get((r, m) => r...);\n     * await sk.model(PersonModel).post((r, m) => r...);\n     * await sk.model(PersonModel).put((r, m) => r...);\n     * await sk.model(PersonModel).patch((r, m) => r...);\n     * await sk.model(PersonModel).delete((r, m) => r...);\n     * \n     * @throws Error if the `modelType` argument missing or falsey.\n     * @throws Error if the `modelType` argument is not a class or constructor function.\n     * @template MT\n     * @param {MT} modelType - The model \"class\" or constructor function.\n     * @returns {StashKu.<MT, InstanceType.<MT>>}\n     */\n    model(modelType) {\n        let parent = this;\n        if (!modelType) {\n            throw new _rest_error_js__WEBPACK_IMPORTED_MODULE_7__[\"default\"](500, 'The \"modelType\" argument is required.');\n        }\n        if (!modelType.constructor || !modelType.prototype) {\n            throw new _rest_error_js__WEBPACK_IMPORTED_MODULE_7__[\"default\"](500, 'The \"modelType\" argument is invalid and must be a class or constructor function.');\n        }\n        if (this.config && this.config.proxy && this.config.proxy.parent) { //prevent parent daisy-chaining\n            parent = this.config.proxy.parent;\n        }\n        return new StashKu({\n            proxy: {\n                parent,\n                model: modelType\n            }\n        });\n    }\n\n    /**\n     * @callback GetRequestCallback\n     * @param {GetRequest} request\n     * @param {M} [model]\n     */\n\n    /**\n     * Run a GET `request` through StashKu using the configured storage engine.    \n     * This operation returns objects from storage that match the GET `request` criteria.    \n     * \n     * @example\n     * let sk = new StashKu();\n     * ...\n     * await sk.get(r => r\n     *     .properties('FirstName', 'LastName')\n     *     .from('Contacts')\n     *     .where(f => f.and('FirstName', f.OP.STARTSWITH, 'Rob'))\n     *     .sort('LastName')\n     * );\n     * \n     * @throws Error if the storage engine fails to return a response.\n     * @throws Error if the storage engine returns an invalid response object.\n     * @param {GetRequest | GetRequestCallback | Request} [request] - The GET request to send to the storage engine.\n     * @returns {Promise.<Response.<I>>} Returns the data objects from storage matching request criteria.\n     */\n    async get(request) {\n        return await this._handle(request ?? new _requests_get_request_js__WEBPACK_IMPORTED_MODULE_1__[\"default\"](), _requests_get_request_js__WEBPACK_IMPORTED_MODULE_1__[\"default\"]);\n    }\n\n    /**\n     * @callback PostRequestCallback\n     * @param {PostRequest} request\n     * @param {M} [model]\n     */\n\n    /**\n     * Run a POST `request` to create objects in a target resource using the StashKu configured storage engine.\n     * This operation returns an array of the objects that were created.\n     * \n     * @example\n     * let sk = new StashKu();\n     * ...\n     * let person1 = { FirstName: 'Robert', LastName: 'Yolo' };\n     * let person2 = { FirstName: 'Suzy', LastName: 'CraftyMine' };\n     * await sk.post(r => r\n     *     .objects(person1, person2)\n     *     .to('Contacts')\n     * );\n     * \n     * @throws Error if the storage engine fails to return a response.\n     * @throws Error if the storage engine returns an invalid response object.\n     * @param {PostRequest | PostRequestCallback} request - The POST request to send to the storage engine.\n     * @returns {Promise.<Response.<I>>} Returns the data objects from storage that were created with the request criteria.\n     */\n    async post(request) {\n        return await this._handle(request, _requests_post_request_js__WEBPACK_IMPORTED_MODULE_4__[\"default\"]);\n    }\n\n    /**\n     * @callback PutRequestCallback\n     * @param {PutRequest} request\n     * @param {M} [model]\n     */\n\n    /**\n     * Run a PUT `request` to update objects in the target resource using the StashKu configured storage engine.\n     * This operation will respond with the objects updated.\n     * \n     * @example\n     * let sk = new StashKu();\n     * ...\n     * let person1 = { ID: 1, FirstName: 'Robert', LastName: 'Yolo' };\n     * let person2 = { ID: 2, FirstName: 'Suzy', LastName: 'CraftyMine' };\n     * await sk.put(r => r\n     *     .objects(person1, person2)\n     *     .pk('ID')\n     *     .to('Contacts')\n     * );\n     * \n     * @throws Error if the storage engine fails to return a response.\n     * @throws Error if the storage engine returns an invalid response object.\n     * @param {PutRequest | PutRequestCallback} request - The PUT request to send to the storage engine.\n     * @returns {Promise.<Response.<I>>} Returns the data objects from storage that were updated with the request criteria. This \n     * *__may not__* exactly match the objects requested to be updated, as some may have been deleted from storage or\n     * some may not match the key criteria.\n     */\n    async put(request) {\n        return await this._handle(request, _requests_put_request_js__WEBPACK_IMPORTED_MODULE_5__[\"default\"]);\n    }\n\n    /**\n     * @callback PatchRequestCallback\n     * @param {PatchRequest} request\n     * @param {M} [model]\n     */\n\n    /**\n     * Run a PATCH `request` to update any matching objects with the specified template properties and values.\n     * This operation will respond with the objects updated.\n     * \n     * @example\n     * let sk = new StashKu();\n     * ...\n     * await sk.patch(r => r\n     *     .template({\n     *         walking: true,\n     *         date_walked: new Date()\n     *     })\n     *     .to('Runners')\n     *     .where(f => f.and('Gender', f.OP.EQUALS, 'Female'))\n     * );\n     * @throws Error if the storage engine fails to return a response.\n     * @throws Error if the storage engine returns an invalid response object.\n     * @param {PatchRequest | PatchRequestCallback} request - The PATCH request to send to the storage engine.\n     * @returns {Promise.<Response.<I>>} Returns a response with the total number of the objects affected in storage. No data\n     * objects are typically returned with this request.\n     */\n    async patch(request) {\n        return await this._handle(request, _requests_patch_request_js__WEBPACK_IMPORTED_MODULE_3__[\"default\"]);\n    }\n\n    /**\n     * @callback DeleteRequestCallback\n     * @param {DeleteRequest} request\n     * @param {M} [model]\n     */\n\n    /**\n     * Run a DELETE `request` to delete any matching objects with the specified template properties and values.\n     * This operation will respond with the objects deleted.\n     * \n     * @example\n     * let sk = new StashKu();\n     * ...\n     * await sk.patch(r => r\n     *     .from('Runners')\n     *     .where(f => f.and('Gender', f.OP.EQUALS, 'Female'))\n     * );\n     * @throws Error if the \"request\" argument is not a callback function or `DeleteRequest` instance.\n     * @param {DeleteRequest | DeleteRequestCallback} request - The DELETE request to send to the storage engine.\n     * @returns {Promise.<Response.<I>>} Returns the data objects from storage that were deleted with the request criteria.\n     */\n    async delete(request) {\n        return await this._handle(request, _requests_delete_request_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"]);\n    }\n\n    /**\n     * @callback OptionsRequestCallback\n     * @param {OptionsRequest} request\n     * @param {M} [model]\n     */\n\n    /**\n     * Run an OPTIONS `request` which returns a dynamically constructed model type which defines how StashKu can \n     * interact with the target (`from`) resource. \n     * @example\n     * let sk = new StashKu();\n     * ...\n     * await sk.options(r => r\n     *     .from('Runners')\n     * );\n     * @throws Error if the \"request\" argument is not a callback function or `OptionsRequest` instance.\n     * @param {OptionsRequest | OptionsRequestCallback} request - The OPTIONS request to send to the storage engine.\n     * @returns {Promise.<Response.<I>>} Returns a response with a single data object- the dynamically created model \n     * configuration.\n     */\n    async options(request) {\n        return await this._handle(request ?? new _requests_options_request_js__WEBPACK_IMPORTED_MODULE_2__[\"default\"](), _requests_options_request_js__WEBPACK_IMPORTED_MODULE_2__[\"default\"]);\n    }\n\n    /**\n     * @callback ModelNameResolveCallback\n     * @param {String} name - The model name defined.\n     * @returns {*} Returns a model type constructor/class associated with the model name.\n     */\n\n    /**\n     * Reads a request defintion from file and returns an instance of that request.\n     * @param {fs.PathOrFileDescriptor} jsonFile - The file path to the JSON formatted file defining a single StashKu request.\n     * @param {{encoding: String, flag: String} | String | fs.BufferEncodingOption} [fsOptions] - File encoding options.\n     * @param {ModelNameResolveCallback} [modelNameResolver] - Callback function that resolves a model name into a model type (constructor/class).\n     * @returns {Promise.<DeleteRequest | GetRequest | PatchRequest | PostRequest | PutRequest | OptionsRequest>}\n     */\n    static async requestFromFile(jsonFile, fsOptions, modelNameResolver) {\n        if (IS_BROWSER === false) {\n            let f = await (await import(/* webpackIgnore: true */'fs/promises')).default.readFile(jsonFile, fsOptions);\n            let obj = JSON.parse(f);\n            return StashKu.requestFromObject(obj, modelNameResolver);\n        }\n        throw new Error('The \"requestFromFile\" function is not supported on this platform.');\n    }\n\n    /**\n     * Converts a StashKu request-like object into an instance of the appropriate StashKu request. This\n     * can be used in conjunction with `JSON.stringify(...)` and subsequently a `JSON.parse(...)` of a request.\n     * \n     * If the object is `null` or `undefined`, a `null` value is returned.\n     * @throws Error if the object is missing a method property.\n     * @throws Error if the method property value is invalid.\n     * @param {*} reqObj - The untyped request object.\n     * @param {ModelNameResolveCallback} [modelNameResolver] - Callback function that resolves a model name into a model type (constructor/class).\n     * @returns {Promise.<DeleteRequest | GetRequest | PatchRequest | PostRequest | PutRequest | OptionsRequest>} \n     */\n    static async requestFromObject(reqObj, modelNameResolver) {\n        if (reqObj) {\n            //handle http.IncomingMessageg\n            if (IS_BROWSER === false && reqObj.url && reqObj.httpVersion) {\n                if (!HttpRequestLoader) {\n                    HttpRequestLoader = (await import(/* webpackIgnore: true */'./node/http-request-loader.js')).default;\n                }\n                return await HttpRequestLoader(reqObj);\n            }\n            if (!reqObj.method || /^delete|get|patch|post|put|options$/i.test(reqObj.method) === false) {\n                throw new Error('The method property value of the object is missing or invalid. Expected a valid request method.');\n            }\n            //construct\n            let mt = null;\n            if (modelNameResolver && reqObj.model) {\n                mt = modelNameResolver(reqObj.model);\n            }\n            switch (reqObj.method.toLowerCase()) {\n                case 'delete': return new _requests_delete_request_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"]()\n                    .model(mt)\n                    .headers(reqObj.headers)\n                    .from(reqObj.from ?? null)\n                    .all(reqObj.all ?? false)\n                    .count(reqObj.count ?? false)\n                    .where(_filter_js__WEBPACK_IMPORTED_MODULE_8__[\"default\"].fromObject(reqObj.where));\n                case 'get': return new _requests_get_request_js__WEBPACK_IMPORTED_MODULE_1__[\"default\"]()\n                    .model(mt)\n                    .headers(reqObj.headers)\n                    .from(reqObj.from ?? null)\n                    .properties(...reqObj.properties)\n                    .distinct(reqObj.distinct ?? false)\n                    .count(reqObj.count ?? false)\n                    .skip(reqObj.skip ?? null)\n                    .take(reqObj.take ?? null)\n                    .sort(...reqObj.sorts)\n                    .where(_filter_js__WEBPACK_IMPORTED_MODULE_8__[\"default\"].fromObject(reqObj.where));\n                case 'options': return new _requests_options_request_js__WEBPACK_IMPORTED_MODULE_2__[\"default\"]()\n                    .model(mt)\n                    .from(reqObj.from ?? null)\n                    .headers(reqObj.headers);\n                case 'patch': return new _requests_patch_request_js__WEBPACK_IMPORTED_MODULE_3__[\"default\"]()\n                    .model(mt)\n                    .headers(reqObj.headers)\n                    .to(reqObj.to ?? null)\n                    .template(reqObj.template ?? null)\n                    .all(reqObj.all ?? false)\n                    .count(reqObj.count ?? false)\n                    .where(_filter_js__WEBPACK_IMPORTED_MODULE_8__[\"default\"].fromObject(reqObj.where));\n                case 'post': return new _requests_post_request_js__WEBPACK_IMPORTED_MODULE_4__[\"default\"]()\n                    .model(mt)\n                    .headers(reqObj.headers)\n                    .to(reqObj.to ?? null)\n                    .count(reqObj.count ?? false)\n                    .objects(reqObj.objects ?? null);\n                case 'put': return new _requests_put_request_js__WEBPACK_IMPORTED_MODULE_5__[\"default\"]()\n                    .model(mt)\n                    .headers(reqObj.headers)\n                    .to(reqObj.to ?? null)\n                    .count(reqObj.count ?? false)\n                    .pk(...reqObj.pk)\n                    .objects(reqObj.objects ?? null);\n            }\n        }\n        return null;\n    }\n\n}\n\n\n\n//# sourceURL=webpack://StashKu/./stashku.js?");

/***/ }),

/***/ "./utilities/pluralize/pluralize.js":
/*!******************************************!*\
  !*** ./utilities/pluralize/pluralize.js ***!
  \******************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (__WEBPACK_DEFAULT_EXPORT__)\n/* harmony export */ });\nfunction pluralize() {\n    // Rule storage - pluralize and singularize need to be run sequentially,\n    // while other rules can be optimized using an object for instant lookups.\n    var pluralRules = [];\n    var singularRules = [];\n    var uncountables = {};\n    var irregularPlurals = {};\n    var irregularSingles = {};\n\n    /**\n     * Sanitize a pluralization rule to a usable regular expression.\n     *\n     * @param  {(RegExp|string)} rule\n     * @return {RegExp}\n     */\n    function sanitizeRule(rule) {\n        if (typeof rule === 'string') {\n            return new RegExp('^' + rule + '$', 'i');\n        }\n\n        return rule;\n    }\n\n    /**\n     * Pass in a word token to produce a function that can replicate the case on\n     * another word.\n     *\n     * @param  {string}   word\n     * @param  {string}   token\n     * @return {Function}\n     */\n    function restoreCase(word, token) {\n        // Tokens are an exact match.\n        if (word === token) return token;\n\n        // Lower cased words. E.g. \"hello\".\n        if (word === word.toLowerCase()) return token.toLowerCase();\n\n        // Upper cased words. E.g. \"WHISKY\".\n        if (word === word.toUpperCase()) return token.toUpperCase();\n\n        // Title cased words. E.g. \"Title\".\n        if (word[0] === word[0].toUpperCase()) {\n            return token.charAt(0).toUpperCase() + token.substr(1).toLowerCase();\n        }\n\n        // Lower cased words. E.g. \"test\".\n        return token.toLowerCase();\n    }\n\n    /**\n     * Interpolate a regexp string.\n     *\n     * @param  {string} str\n     * @param  {Array}  args\n     * @return {string}\n     */\n    function interpolate(str, args) {\n        return str.replace(/\\$(\\d{1,2})/g, function (match, index) {\n            return args[index] || '';\n        });\n    }\n\n    /**\n     * Replace a word using a rule.\n     *\n     * @param  {string} word\n     * @param  {Array}  rule\n     * @return {string}\n     */\n    function replace(word, rule) {\n        return word.replace(rule[0], function (match, index) {\n            var result = interpolate(rule[1], arguments);\n\n            if (match === '') {\n                return restoreCase(word[index - 1], result);\n            }\n\n            return restoreCase(match, result);\n        });\n    }\n\n    /**\n     * Sanitize a word by passing in the word and sanitization rules.\n     *\n     * @param  {string}   token\n     * @param  {string}   word\n     * @param  {Array}    rules\n     * @return {string}\n     */\n    function sanitizeWord(token, word, rules) {\n        // Empty string or doesn't need fixing.\n        if (!token.length || uncountables.hasOwnProperty(token)) {\n            return word;\n        }\n\n        var len = rules.length;\n\n        // Iterate over the sanitization rules and use the first one to match.\n        while (len--) {\n            var rule = rules[len];\n\n            if (rule[0].test(word)) return replace(word, rule);\n        }\n\n        return word;\n    }\n\n    /**\n     * Replace a word with the updated word.\n     *\n     * @param  {Object}   replaceMap\n     * @param  {Object}   keepMap\n     * @param  {Array}    rules\n     * @return {Function}\n     */\n    function replaceWord(replaceMap, keepMap, rules) {\n        return function (word) {\n            // Get the correct token and case restoration functions.\n            var token = word.toLowerCase();\n\n            // Check against the keep object map.\n            if (keepMap.hasOwnProperty(token)) {\n                return restoreCase(word, token);\n            }\n\n            // Check against the replacement map for a direct word replacement.\n            if (replaceMap.hasOwnProperty(token)) {\n                return restoreCase(word, replaceMap[token]);\n            }\n\n            // Run all the rules against the word.\n            return sanitizeWord(token, word, rules);\n        };\n    }\n\n    /**\n     * Check if a word is part of the map.\n     */\n    function checkWord(replaceMap, keepMap, rules, bool) {\n        return function (word) {\n            var token = word.toLowerCase();\n\n            if (keepMap.hasOwnProperty(token)) return true;\n            if (replaceMap.hasOwnProperty(token)) return false;\n\n            return sanitizeWord(token, token, rules) === token;\n        };\n    }\n\n    /**\n     * Pluralize or singularize a word based on the passed in count.\n     *\n     * @param  {string}  word      The word to pluralize\n     * @param  {number}  count     How many of the word exist\n     * @param  {boolean} inclusive Whether to prefix with the number (e.g. 3 ducks)\n     * @return {string}\n     */\n    function pluralize(word, count, inclusive) {\n        var pluralized = count === 1\n            ? pluralize.singular(word) : pluralize.plural(word);\n\n        return (inclusive ? count + ' ' : '') + pluralized;\n    }\n\n    /**\n     * Pluralize a word.\n     *\n     * @type {Function}\n     */\n    pluralize.plural = replaceWord(\n        irregularSingles, irregularPlurals, pluralRules\n    );\n\n    /**\n     * Check if a word is plural.\n     *\n     * @type {Function}\n     */\n    pluralize.isPlural = checkWord(\n        irregularSingles, irregularPlurals, pluralRules\n    );\n\n    /**\n     * Singularize a word.\n     *\n     * @type {Function}\n     */\n    pluralize.singular = replaceWord(\n        irregularPlurals, irregularSingles, singularRules\n    );\n\n    /**\n     * Check if a word is singular.\n     *\n     * @type {Function}\n     */\n    pluralize.isSingular = checkWord(\n        irregularPlurals, irregularSingles, singularRules\n    );\n\n    /**\n     * Add a pluralization rule to the collection.\n     *\n     * @param {(string|RegExp)} rule\n     * @param {string}          replacement\n     */\n    pluralize.addPluralRule = function (rule, replacement) {\n        pluralRules.push([sanitizeRule(rule), replacement]);\n    };\n\n    /**\n     * Add a singularization rule to the collection.\n     *\n     * @param {(string|RegExp)} rule\n     * @param {string}          replacement\n     */\n    pluralize.addSingularRule = function (rule, replacement) {\n        singularRules.push([sanitizeRule(rule), replacement]);\n    };\n\n    /**\n     * Add an uncountable word rule.\n     *\n     * @param {(string|RegExp)} word\n     */\n    pluralize.addUncountableRule = function (word) {\n        if (typeof word === 'string') {\n            uncountables[word.toLowerCase()] = true;\n            return;\n        }\n\n        // Set singular and plural references for the word.\n        pluralize.addPluralRule(word, '$0');\n        pluralize.addSingularRule(word, '$0');\n    };\n\n    /**\n     * Add an irregular word definition.\n     *\n     * @param {string} single\n     * @param {string} plural\n     */\n    pluralize.addIrregularRule = function (single, plural) {\n        plural = plural.toLowerCase();\n        single = single.toLowerCase();\n\n        irregularSingles[single] = plural;\n        irregularPlurals[plural] = single;\n    };\n\n    /**\n     * Irregular rules.\n     */\n    [\n        // Pronouns.\n        ['I', 'we'],\n        ['me', 'us'],\n        ['he', 'they'],\n        ['she', 'they'],\n        ['them', 'them'],\n        ['myself', 'ourselves'],\n        ['yourself', 'yourselves'],\n        ['itself', 'themselves'],\n        ['herself', 'themselves'],\n        ['himself', 'themselves'],\n        ['themself', 'themselves'],\n        ['is', 'are'],\n        ['was', 'were'],\n        ['has', 'have'],\n        ['this', 'these'],\n        ['that', 'those'],\n        ['my', 'our'],\n        ['its', 'their'],\n        ['his', 'their'],\n        ['her', 'their'],\n        // Words ending in with a consonant and `o`.\n        ['echo', 'echoes'],\n        ['dingo', 'dingoes'],\n        ['volcano', 'volcanoes'],\n        ['tornado', 'tornadoes'],\n        ['torpedo', 'torpedoes'],\n        // Ends with `us`.\n        ['genus', 'genera'],\n        ['viscus', 'viscera'],\n        // Ends with `ma`.\n        ['stigma', 'stigmata'],\n        ['stoma', 'stomata'],\n        ['dogma', 'dogmata'],\n        ['lemma', 'lemmata'],\n        ['schema', 'schemata'],\n        ['anathema', 'anathemata'],\n        // Other irregular rules.\n        ['ox', 'oxen'],\n        ['axe', 'axes'],\n        ['die', 'dice'],\n        ['yes', 'yeses'],\n        ['foot', 'feet'],\n        ['eave', 'eaves'],\n        ['goose', 'geese'],\n        ['tooth', 'teeth'],\n        ['quiz', 'quizzes'],\n        ['human', 'humans'],\n        ['proof', 'proofs'],\n        ['carve', 'carves'],\n        ['valve', 'valves'],\n        ['looey', 'looies'],\n        ['thief', 'thieves'],\n        ['groove', 'grooves'],\n        ['pickaxe', 'pickaxes'],\n        ['passerby', 'passersby'],\n        ['canvas', 'canvases']\n    ].forEach(function (rule) {\n        return pluralize.addIrregularRule(rule[0], rule[1]);\n    });\n\n    /**\n     * Pluralization rules.\n     */\n    [\n        [/s?$/i, 's'],\n        [/[^\\u0000-\\u007F]$/i, '$0'],\n        [/([^aeiou]ese)$/i, '$1'],\n        [/(ax|test)is$/i, '$1es'],\n        [/(alias|[^aou]us|t[lm]as|gas|ris)$/i, '$1es'],\n        [/(e[mn]u)s?$/i, '$1s'],\n        [/([^l]ias|[aeiou]las|[ejzr]as|[iu]am)$/i, '$1'],\n        [/(alumn|syllab|vir|radi|nucle|fung|cact|stimul|termin|bacill|foc|uter|loc|strat)(?:us|i)$/i, '$1i'],\n        [/(alumn|alg|vertebr)(?:a|ae)$/i, '$1ae'],\n        [/(seraph|cherub)(?:im)?$/i, '$1im'],\n        [/(her|at|gr)o$/i, '$1oes'],\n        [/(agend|addend|millenni|dat|extrem|bacteri|desiderat|strat|candelabr|errat|ov|symposi|curricul|automat|quor)(?:a|um)$/i, '$1a'],\n        [/(apheli|hyperbat|periheli|asyndet|noumen|phenomen|criteri|organ|prolegomen|hedr|automat)(?:a|on)$/i, '$1a'],\n        [/sis$/i, 'ses'],\n        [/(?:(kni|wi|li)fe|(ar|l|ea|eo|oa|hoo)f)$/i, '$1$2ves'],\n        [/([^aeiouy]|qu)y$/i, '$1ies'],\n        [/([^ch][ieo][ln])ey$/i, '$1ies'],\n        [/(x|ch|ss|sh|zz)$/i, '$1es'],\n        [/(matr|cod|mur|sil|vert|ind|append)(?:ix|ex)$/i, '$1ices'],\n        [/\\b((?:tit)?m|l)(?:ice|ouse)$/i, '$1ice'],\n        [/(pe)(?:rson|ople)$/i, '$1ople'],\n        [/(child)(?:ren)?$/i, '$1ren'],\n        [/eaux$/i, '$0'],\n        [/m[ae]n$/i, 'men'],\n        ['thou', 'you']\n    ].forEach(function (rule) {\n        return pluralize.addPluralRule(rule[0], rule[1]);\n    });\n\n    /**\n     * Singularization rules.\n     */\n    [\n        [/s$/i, ''],\n        [/(ss)$/i, '$1'],\n        [/(wi|kni|(?:after|half|high|low|mid|non|night|[^\\w]|^)li)ves$/i, '$1fe'],\n        [/(ar|(?:wo|[ae])l|[eo][ao])ves$/i, '$1f'],\n        [/ies$/i, 'y'],\n        [/(dg|ss|ois|lk|ok|wn|mb|th|ch|ec|oal|is|ck|ix|sser|ts|wb)ies$/i, '$1ie'],\n        [/\\b(l|(?:neck|cross|hog|aun)?t|coll|faer|food|gen|goon|group|hipp|junk|vegg|(?:pork)?p|charl|calor|cut)ies$/i, '$1ie'],\n        [/\\b(mon|smil)ies$/i, '$1ey'],\n        [/\\b((?:tit)?m|l)ice$/i, '$1ouse'],\n        [/(seraph|cherub)im$/i, '$1'],\n        [/(x|ch|ss|sh|zz|tto|go|cho|alias|[^aou]us|t[lm]as|gas|(?:her|at|gr)o|[aeiou]ris)(?:es)?$/i, '$1'],\n        [/(analy|diagno|parenthe|progno|synop|the|empha|cri|ne)(?:sis|ses)$/i, '$1sis'],\n        [/(movie|twelve|abuse|e[mn]u)s$/i, '$1'],\n        [/(test)(?:is|es)$/i, '$1is'],\n        [/(alumn|syllab|vir|radi|nucle|fung|cact|stimul|termin|bacill|foc|uter|loc|strat)(?:us|i)$/i, '$1us'],\n        [/(agend|addend|millenni|dat|extrem|bacteri|desiderat|strat|candelabr|errat|ov|symposi|curricul|quor)a$/i, '$1um'],\n        [/(apheli|hyperbat|periheli|asyndet|noumen|phenomen|criteri|organ|prolegomen|hedr|automat)a$/i, '$1on'],\n        [/(alumn|alg|vertebr)ae$/i, '$1a'],\n        [/(cod|mur|sil|vert|ind)ices$/i, '$1ex'],\n        [/(matr|append)ices$/i, '$1ix'],\n        [/(pe)(rson|ople)$/i, '$1rson'],\n        [/(child)ren$/i, '$1'],\n        [/(eau)x?$/i, '$1'],\n        [/men$/i, 'man']\n    ].forEach(function (rule) {\n        return pluralize.addSingularRule(rule[0], rule[1]);\n    });\n\n    /**\n     * Uncountable rules.\n     */\n    [\n        // Singular words with no plurals.\n        'adulthood',\n        'advice',\n        'agenda',\n        'aid',\n        'aircraft',\n        'alcohol',\n        'ammo',\n        'analytics',\n        'anime',\n        'athletics',\n        'audio',\n        'bison',\n        'blood',\n        'bream',\n        'buffalo',\n        'butter',\n        'carp',\n        'cash',\n        'chassis',\n        'chess',\n        'clothing',\n        'cod',\n        'commerce',\n        'cooperation',\n        'corps',\n        'debris',\n        'diabetes',\n        'digestion',\n        'elk',\n        'energy',\n        'equipment',\n        'excretion',\n        'expertise',\n        'firmware',\n        'flounder',\n        'fun',\n        'gallows',\n        'garbage',\n        'graffiti',\n        'hardware',\n        'headquarters',\n        'health',\n        'herpes',\n        'highjinks',\n        'homework',\n        'housework',\n        'information',\n        'jeans',\n        'justice',\n        'kudos',\n        'labour',\n        'literature',\n        'machinery',\n        'mackerel',\n        'mail',\n        'media',\n        'mews',\n        'moose',\n        'music',\n        'mud',\n        'manga',\n        'news',\n        'only',\n        'personnel',\n        'pike',\n        'plankton',\n        'pliers',\n        'police',\n        'pollution',\n        'premises',\n        'rain',\n        'research',\n        'rice',\n        'salmon',\n        'scissors',\n        'series',\n        'sewage',\n        'shambles',\n        'shrimp',\n        'software',\n        'staff',\n        'swine',\n        'tennis',\n        'traffic',\n        'transportation',\n        'trout',\n        'tuna',\n        'wealth',\n        'welfare',\n        'whiting',\n        'wildebeest',\n        'wildlife',\n        'you',\n        /pok[e]mon$/i,\n        // Regexes.\n        /[^aeiou]ese$/i, // \"chinese\", \"japanese\"\n        /deer$/i, // \"deer\", \"reindeer\"\n        /fish$/i, // \"fish\", \"blowfish\", \"angelfish\"\n        /measles$/i,\n        /o[iu]s$/i, // \"carnivorous\"\n        /pox$/i, // \"chickpox\", \"smallpox\"\n        /sheep$/i\n    ].forEach(pluralize.addUncountableRule);\n\n    return pluralize;\n}\n\n/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (pluralize());\n\n//# sourceURL=webpack://StashKu/./utilities/pluralize/pluralize.js?");

/***/ }),

/***/ "./utilities/string-utility.js":
/*!*************************************!*\
  !*** ./utilities/string-utility.js ***!
  \*************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (__WEBPACK_DEFAULT_EXPORT__)\n/* harmony export */ });\n/* harmony import */ var _pluralize_pluralize_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./pluralize/pluralize.js */ \"./utilities/pluralize/pluralize.js\");\n\n\nconst StringUtility = {\n\n    /**\n     * Returns the english plural form of the given input string.\n     * @param {String} input - The value to be pluralized.\n     * @returns {String}\n     */\n    plural(input) {\n        return _pluralize_pluralize_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"].plural(input);\n    },\n\n    /**\n     * Returns the english singular form of the given input string.\n     * @param {String} input - The value to be made into it's singular form.\n     * @returns {String}\n     */\n    singular(input) {\n        return _pluralize_pluralize_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"].singular(input);\n    },\n\n    /**\n     * Attempts to parse a regular expression literal string, potentially including flags.\n     * @param {String|RegExp} input - The regular expression literal string.\n     * @returns {RegExp}\n     */\n    toRegExp: function (input) {\n        if (input instanceof RegExp) {\n            return input;\n        }\n        if (typeof input === 'string') {\n            let firstSlash = input.indexOf('/');\n            let lastSlash = input.lastIndexOf('/');\n            let flags = null;\n            //check if the regexp is in literal format and may include flags\n            if (firstSlash === 0 && lastSlash > -1 && firstSlash !== lastSlash) {\n                //looks like a regex string with potential flags\n                flags = input.substr(lastSlash + 1);\n                //strip slashes.\n                input = input.substring(firstSlash + 1, lastSlash);\n            }\n            if (flags) {\n                return new RegExp(input, flags);\n            } else {\n                return new RegExp(input);\n            }\n        }\n        return null;\n    },\n\n    /**\n     * Escape a string value using the given method so it can be safely parsed.\n     * @param {String} input - The string value to escape.\n     * @param {StringUtility.EscapeMethod|Number} method - The escape method to use.\n     * @returns {String}\n     */\n    escape: function (input, method) {\n        if (method == StringUtility.EscapeMethod.URI) {\n            return escape(input);\n        } else if (method === StringUtility.EscapeMethod.REGEXP) {\n            //eslint-disable-next-line no-useless-escape\n            return input.replace(/[\\-\\[\\]\\/\\{\\}\\(\\)\\*\\+\\?\\.\\\\\\^\\$\\|]/g, '\\\\$&');\n        }\n        throw new Error('A valid \"method\" argument is reguired.');\n    },\n\n    /**\n     * Checks if the input string matches any one of the given test values.\n     * @param {String} input - The string to test for a match.\n     * @param {String|String[]|RegExp|RegExp[]} test - The string(s) or RegExp to test the input against.\n     * @param {Boolean} [insensitive=false] - If true, the test will be made case-insensitive.\n     * @returns {Boolean}\n     */\n    some: function (input, test, insensitive) {\n        if (typeof input === 'undefined') {\n            return false;\n        } else if (input === null && input === test) {\n            return true;\n        }\n        if (Array.isArray(test) === false) {\n            test = [test];\n        }\n        for (let t of test) {\n            if (typeof t === 'string') {\n                if (input === t || (insensitive && input.toLowerCase() === t.toLowerCase())) {\n                    return true;\n                }\n            } else if (t instanceof RegExp) {\n                if (insensitive && t.ignoreCase === false) {\n                    t = new RegExp(t.source, t.flags + 'i');\n                }\n                return t.test(input);\n            }\n        }\n        return false;\n    },\n\n    /**\n     * @param {String} input - The input string to convert to a URL-friendly slug.\n     * @param {String} [sep=\"-\"] - The seperator string between words. Defaults to a \"-\".\n     * @param {Boolean} [lower=true] - Toggles whether to convert the output slug to lower-case. Defaults to true.\n     * @param {Boolean} [camel=false] - Converts camel or VB -case inputs to a friendly slug. Defaults to false.\n     * @returns {String}\n     */\n    slugify: function (input, sep, lower, camel) {\n        if (typeof sep === 'undefined') {\n            sep = '-';\n        } else if (sep === null) {\n            sep = '';\n        }\n        let escSep = StringUtility.escape(sep, StringUtility.EscapeMethod.REGEXP);\n        //normalize diacritics and remove un-processable characters.\n        input = input\n            .normalize('NFKD')\n            .replace(/[^\\w\\s.\\-_\\\\/,:;<>|`~!@#$%^&*()[\\]]/g, '');\n        //handle camel-case inputs\n        if (camel) {\n            input = input.split('').reduce((pv, cv, index, arr) => {\n                if (cv.match(/[A-Z]/) && pv.match(/[^A-Z]$/)) {\n                    return pv + sep + cv;\n                } else if (cv.match(/[A-Z]/) && pv.match(/[A-Z]/) && arr.length > index + 1 && arr[index + 1].match(/[a-z-]/)) {\n                    //current is upper, last was upper, but next is lower (possible tail of uppercase chain)\n                    return pv + sep + cv;\n                }\n                return pv + cv;\n            }, '');\n        }\n        input = input\n            .replace(/[\\s.\\-_\\\\/,:;<>|`~!@#$%^&*()[\\]]+/g, sep) //replace allowed punctuation\n            .replace(new RegExp(`^${escSep}*|${escSep}*$`, 'g'), '') //trim ends\n            .replace(new RegExp(escSep + '+', 'g'), sep); //collapse dashes\n        //make the output lowercase if specified.\n        if (typeof lower === 'undefined' || lower) {\n            input = input.toLowerCase();\n        }\n        return input;\n    },\n\n    /**\n     * Converts an input string to a consistent camel-Case name.\n     * @param {String} input - The name to be standardized.\n     * @param {Boolean} [pascal=false] - Optional flag that when `true` will always capitalize the first letter.\n     * @returns {String}\n     */\n    camelify: function (input, pascal = false) {\n        if (input) {\n            //normalize diacritics and remove un-processable characters and split into words.\n            let words = input\n                .normalize('NFKD')\n                .replace(/[^\\w\\s.\\-_\\\\/,:;<>|`~!@#$%^&*()[]]/g, '')\n                .split(/[^A-Za-z0-9]/g);\n            let count = 0;\n            input = words.reduce((pv, cv, i) => {\n                if (cv.length) {\n                    let uppered = cv.toUpperCase();\n                    //if a single word name and uppercase, always just return lowercase.\n                    if (uppered === 'ID' || uppered == 'UUID' || uppered === 'GUID') {\n                        //except for certain acronyms\n                        count++;\n                        return pv + uppered;\n                    } else if (words.length === 1 && uppered === cv) {\n                        count++;\n                        return cv.toLowerCase();\n                    } else if (uppered !== cv) { //word is not all uppercase\n                        let camel = (count > 0 ? cv[0].toUpperCase() : cv[0].toLowerCase());\n                        camel += cv.substr(1);\n                        count++;\n                        return pv + camel;\n                    } else if (uppered === cv) {\n                        count++;\n                    }\n                }\n                return pv + cv;\n            }, '');\n            if (pascal) {\n                return input[0].toUpperCase() + input.substr(1);\n            }\n        }\n        return input;\n    },\n\n    /**\n     * Truncates a given string up to the max. length, and adds an ellipsis if necessary.\n     * @param {String} input - The string to (potentially) truncate.\n     * @param {Number} max - The max. length of the input string allowed before it is truncated.\n     * @returns {String}\n     */\n    truncate: function (input, max) {\n        return (input.length < max) ? input : input.substring(0, max).replace(/.{3}$/gi, '...');\n    },\n\n    /**\n     * Truncates a given string from the tail-end (reverse truncate) up to the max. length, and adds an ellipsis if\n     * necessary.\n     * @param {String} input - The string to (potentially) truncate.\n     * @param {Number} max - The max. length of the input string allowed before it is truncated.\n     * @returns {String}\n     */\n    tail: function (input, max) {\n        return (input.length < max) ? input : input.substring(input.length - max).replace(/^.{3}/gi, '...');\n    },\n\n    /**\n     * Indents all or specific lines of text in a string.\n     * @param {String} input - The string to indent.\n     * @param {Number} [start] - The line index to start indenting.\n     * @param {Number} [end] - The line index to stop indenting after.\n     * @param {String} [indent=\"    \"] - The indentation to use on each matched line. \n     * @returns {String}\n     */\n    indent: function (input, start, end, indent = '    ') {\n        if (typeof input === 'string') {\n            let hasStart = !(typeof start === 'undefined' || start === null);\n            let hasEnd = !(typeof end === 'undefined' || end === null);\n            let counter = 0;\n            return input.replace(/^/gm, (_match, _index, _str) => {\n                let output = '';\n                if (hasStart === false || (hasStart && counter >= start)) {\n                    if (hasEnd === false || (hasEnd && counter <= end)) {\n                        output = indent;\n                    }\n                }\n                counter++;\n                return output;\n            });\n        }\n        return input;\n    }\n\n};\n\n/**\n * @enum {Number}\n * @readonly\n */\nStringUtility.EscapeMethod = {\n    URI: 0,\n    REGEXP: 1\n};\n\n/** @exports StringUtility */\n/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (StringUtility);\n\n//# sourceURL=webpack://StashKu/./utilities/string-utility.js?");

/***/ })

/******/ 	});
/************************************************************************/
/******/ 	// The module cache
/******/ 	var __webpack_module_cache__ = {};
/******/ 	
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/ 		// Check if module is in cache
/******/ 		var cachedModule = __webpack_module_cache__[moduleId];
/******/ 		if (cachedModule !== undefined) {
/******/ 			return cachedModule.exports;
/******/ 		}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = __webpack_module_cache__[moduleId] = {
/******/ 			// no module.id needed
/******/ 			// no module.loaded needed
/******/ 			exports: {}
/******/ 		};
/******/ 	
/******/ 		// Execute the module function
/******/ 		__webpack_modules__[moduleId](module, module.exports, __webpack_require__);
/******/ 	
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/ 	
/************************************************************************/
/******/ 	/* webpack/runtime/define property getters */
/******/ 	(() => {
/******/ 		// define getter functions for harmony exports
/******/ 		__webpack_require__.d = (exports, definition) => {
/******/ 			for(var key in definition) {
/******/ 				if(__webpack_require__.o(definition, key) && !__webpack_require__.o(exports, key)) {
/******/ 					Object.defineProperty(exports, key, { enumerable: true, get: definition[key] });
/******/ 				}
/******/ 			}
/******/ 		};
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/hasOwnProperty shorthand */
/******/ 	(() => {
/******/ 		__webpack_require__.o = (obj, prop) => (Object.prototype.hasOwnProperty.call(obj, prop))
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/make namespace object */
/******/ 	(() => {
/******/ 		// define __esModule on exports
/******/ 		__webpack_require__.r = (exports) => {
/******/ 			if(typeof Symbol !== 'undefined' && Symbol.toStringTag) {
/******/ 				Object.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });
/******/ 			}
/******/ 			Object.defineProperty(exports, '__esModule', { value: true });
/******/ 		};
/******/ 	})();
/******/ 	
/************************************************************************/
/******/ 	
/******/ 	// startup
/******/ 	// Load entry module and return exports
/******/ 	// This entry module can't be inlined because the eval devtool is used.
/******/ 	var __webpack_exports__ = __webpack_require__("./stashku.js");
/******/ 	StashKu = __webpack_exports__;
/******/ 	
/******/ })()
;